// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;
import meta::pure::dsl::dataframe::metamodel::column::*;
import meta::pure::dsl::snowflake::*;
import meta::pure::dsl::duckdb::*;
import meta::pure::dsl::tests::*;

/**
 * Tests for the DataFrame DSL and SQL generators
 */

function <<test.Test>> meta::pure::dsl::tests::testSimpleSelect(): Boolean[1]
{
   // Define a table schema
   let customerSchema = ^TableSchema<Any>(
      name = 'customers',
      columns = newMap([
         pair('id', Integer), 
         pair('name', String)
      ])
   );
   
   // Create a table with schema
   let customersTable = tableWithSchema('customers', $customerSchema);
   
   // Create a simple SELECT query using type-safe constructs
   let df = select([
      as(col('id'), 'id'),
      as(col('name'), 'name')
   ])->from(table('customers'));
   
   // Type-safe version using tilde notation
   let typeSafeDf = select(~($customerSchema, ['id', 'name']))->from($customersTable);
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $typeSafeDf->generateSnowflakeSQL();
   assertEquals('SELECT id, name\nFROM customers', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $typeSafeDf->generateDuckDBSQL();
   assertEquals('SELECT id, name\nFROM customers', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testSelectWithFilter(): Boolean[1]
{
   // Define a table schema
   let customerSchema = ^TableSchema<Any>(
      name = 'customers',
      columns = newMap([
         pair('id', Integer), 
         pair('name', String)
      ])
   );
   
   // Create a table with schema
   let customersTable = tableWithSchema('customers', $customerSchema);
   
   // Create a SELECT query with WHERE clause
   let df = select([
      as(col('id'), 'id'),
      as(col('name'), 'name')
   ])->from(table('customers'))->where(eq(col('id'), literal(100)));
   
   // Type-safe version using tilde notation and filter function
   let typeSafeDf = select(~($customerSchema, ['id', 'name']))
      ->from($customersTable)
      ->filter($customerSchema, {x | $x.id == 100});
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nWHERE (id = 100)', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nWHERE (id = 100)', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testSelectWithJoin(): Boolean[1]
{
   // Create a SELECT query with JOIN
   let df = select([
      as(col('c', 'id'), 'customer_id'),
      as(col('c', 'name'), 'customer_name'),
      as(col('o', 'id'), 'order_id')
   ])->from(
      join(
         tableAs('customers', 'c'),
         tableAs('orders', 'o'),
         eq(col('c', 'id'), col('o', 'customer_id'))
      )
   );
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT c.id AS customer_id, c.name AS customer_name, o.id AS order_id\nFROM customers AS c INNER JOIN orders AS o ON (c.id = o.customer_id)', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT c.id AS customer_id, c.name AS customer_name, o.id AS order_id\nFROM customers AS c INNER JOIN orders AS o ON (c.id = o.customer_id)', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testSelectWithGroupBy(): Boolean[1]
{
   // Define a table schema
   let orderSchema = ^TableSchema<Any>(
      name = 'orders',
      columns = newMap([
         pair('id', Integer), 
         pair('category', String),
         pair('amount', Decimal)
      ])
   );
   
   // Create a table with schema
   let ordersTable = tableWithSchema('orders', $orderSchema);
   
   // Create a SELECT query with GROUP BY and aggregate functions
   let df = select([
      as(col('category'), 'category'),
      as(count(col('id')), 'count'),
      as(sum(col('amount')), 'total_amount')
   ])->from(table('orders'))->groupBy([col('category')]);
   
   // Type-safe version using tilde notation
   let typeSafeDf = select([
      as(~($orderSchema, 'category'), 'category'),
      as(count(~($orderSchema, 'id')), 'count'),
      as(sum(~($orderSchema, 'amount')), 'total_amount')
   ])->from($ordersTable)->groupBy(~($orderSchema, 'category'));
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT category AS category, COUNT(id) AS count, SUM(amount) AS total_amount\nFROM orders\nGROUP BY category', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT category AS category, COUNT(id) AS count, SUM(amount) AS total_amount\nFROM orders\nGROUP BY category', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testSelectWithOrderBy(): Boolean[1]
{
   // Define a table schema
   let customerSchema = ^TableSchema<Any>(
      name = 'customers',
      columns = newMap([
         pair('id', Integer), 
         pair('name', String)
      ])
   );
   
   // Create a table with schema
   let customersTable = tableWithSchema('customers', $customerSchema);
   
   // Create a SELECT query with ORDER BY
   let df = select([
      as(col('id'), 'id'),
      as(col('name'), 'name')
   ])->from(table('customers'))->orderBy([asc(col('name')), desc(col('id'))]);
   
   // Type-safe version using tilde notation
   let typeSafeDf = select(~($customerSchema, ['id', 'name']))
      ->from($customersTable)
      ->orderBy(~($customerSchema, 'name'), false)  // ASC
      ->orderBy(~($customerSchema, 'id'), true);    // DESC
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nORDER BY name ASC, id DESC', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nORDER BY name ASC, id DESC', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testSelectWithLimit(): Boolean[1]
{
   // Define a table schema
   let customerSchema = ^TableSchema<Any>(
      name = 'customers',
      columns = newMap([
         pair('id', Integer), 
         pair('name', String)
      ])
   );
   
   // Create a table with schema
   let customersTable = tableWithSchema('customers', $customerSchema);
   
   // Create a SELECT query with LIMIT and OFFSET
   let df = select([
      as(col('id'), 'id'),
      as(col('name'), 'name')
   ])->from(table('customers'))->limit(10)->offset(20);
   
   // Type-safe version using tilde notation
   let typeSafeDf = select(~($customerSchema, ['id', 'name']))
      ->from($customersTable)
      ->limit(10)
      ->offset(20);
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nLIMIT 10\nOFFSET 20', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT id AS id, name AS name\nFROM customers\nLIMIT 10\nOFFSET 20', $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testComplexQuery(): Boolean[1]
{
   // Create a complex SELECT query with multiple features
   let df = selectDistinct([
      as(col('c', 'category'), 'category'),
      as(count(col('o', 'id')), 'order_count'),
      as(sum(col('o', 'amount')), 'total_amount')
   ])->from(
      leftJoin(
         tableAs('categories', 'c'),
         tableAs('orders', 'o'),
         eq(col('c', 'id'), col('o', 'category_id'))
      )
   )->where(
      and(
         gt(col('o', 'amount'), literal(100)),
         isNotNull(col('o', 'customer_id'))
      )
   )->groupBy([
      col('c', 'category')
   ])->having(
      gt(count(col('o', 'id')), literal(5))
   )->orderBy([
      desc(sum(col('o', 'amount')))
   ])->limit(5);
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   let expectedSnowflakeSQL = 'SELECT DISTINCT c.category AS category, COUNT(o.id) AS order_count, SUM(o.amount) AS total_amount\n' +
                             'FROM categories AS c LEFT OUTER JOIN orders AS o ON (c.id = o.category_id)\n' +
                             'WHERE ((o.amount > 100) AND (o.customer_id IS NOT NULL))\n' +
                             'GROUP BY c.category\n' +
                             'HAVING (COUNT(o.id) > 5)\n' +
                             'ORDER BY SUM(o.amount) DESC\n' +
                             'LIMIT 5';
   assertEquals($expectedSnowflakeSQL, $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   let expectedDuckDBSQL = 'SELECT DISTINCT c.category AS category, COUNT(o.id) AS order_count, SUM(o.amount) AS total_amount\n' +
                          'FROM categories AS c LEFT JOIN orders AS o ON (c.id = o.category_id)\n' +
                          'WHERE ((o.amount > 100) AND (o.customer_id IS NOT NULL))\n' +
                          'GROUP BY c.category\n' +
                          'HAVING (COUNT(o.id) > 5)\n' +
                          'ORDER BY SUM(o.amount) DESC\n' +
                          'LIMIT 5';
   assertEquals($expectedDuckDBSQL, $duckdbSQL);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testDatabaseSpecificSyntaxDifferences(): Boolean[1]
{
   // Test a case where Snowflake and DuckDB have different syntax
   // In this case, LEFT OUTER JOIN vs LEFT JOIN
   let df = select([
      as(col('c', 'name'), 'customer_name'),
      as(col('o', 'id'), 'order_id')
   ])->from(
      leftJoin(
         tableAs('customers', 'c'),
         tableAs('orders', 'o'),
         eq(col('c', 'id'), col('o', 'customer_id'))
      )
   );
   
   // Generate SQL for Snowflake
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT c.name AS customer_name, o.id AS order_id\nFROM customers AS c LEFT OUTER JOIN orders AS o ON (c.id = o.customer_id)', $snowflakeSQL);
   
   // Generate SQL for DuckDB
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT c.name AS customer_name, o.id AS order_id\nFROM customers AS c LEFT JOIN orders AS o ON (c.id = o.customer_id)', $duckdbSQL);
   
   true;
}

// Tests for type-safe features

function <<test.Test>> meta::pure::dsl::tests::testTypeSafeColSpec(): Boolean[1]
{
   // Test ColSpec creation with tilde notation
   let col = ~'column1';
   assertEquals('column1', $col.name);
   
   // Test ColSpecArray creation with tilde notation
   let cols = ~['col1', 'col2', 'col3'];
   assertEquals(['col1', 'col2', 'col3'], $cols.names->joinStrings(', '));
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testTypeSafeAggregateFunctions(): Boolean[1]
{
   // Test type-safe aggregate functions
   let sumCol = sum(~'value');
   assertEquals('sum_value', $sumCol.name);
   
   let avgCol = avg(~'price');
   assertEquals('avg_price', $avgCol.name);
   
   let minCol = min(~'score');
   assertEquals('min_score', $minCol.name);
   
   let maxCol = max(~'rating');
   assertEquals('max_rating', $maxCol.name);
   
   true;
}

function <<test.Test>> meta::pure::dsl::tests::testTypeSafeWindowSpec(): Boolean[1]
{
   // Test window specification with tilde notation
   let windowSpec1 = over(~'department');
   assertEquals(['department'], $windowSpec1.partitionBy->joinStrings(', '));
   assertEquals([], $windowSpec1.orderBy);
   
   let windowSpec2 = over(~['region', 'department']);
   assertEquals(['region', 'department'], $windowSpec2.partitionBy->joinStrings(', '));
   assertEquals([], $windowSpec2.orderBy);
   
   let windowSpec3 = over(~'department', ~'salary');
   assertEquals(['department'], $windowSpec3.partitionBy->joinStrings(', '));
   assertEquals(['salary'], $windowSpec3.orderBy->joinStrings(', '));
   
   let windowSpec4 = over(~['region', 'department'], ~['date', 'id']);
   assertEquals(['region', 'department'], $windowSpec4.partitionBy->joinStrings(', '));
   assertEquals(['date', 'id'], $windowSpec4.orderBy->joinStrings(', '));
   
   true;
}

// Helper function for testing
function <<access.private>> meta::pure::dsl::tests::assertEquals(expected: String[1], actual: String[1]): Boolean[1]
{
   if($expected != $actual)
   {
      print('Expected: ' + $expected + '\nActual: ' + $actual);
      false;
   }
   else
   {
      true;
   }
}

// Helper function for testing with Any type
function <<access.private>> meta::pure::dsl::tests::assertEquals(expected: Any[1], actual: Any[1]): Boolean[1]
{
   if($expected != $actual)
   {
      print('Expected: ' + $expected->toString() + '\nActual: ' + $actual->toString());
      false;
   }
   else
   {
      true;
   }
}

function <<test.Test>> meta::pure::dsl::tests::testTableSchemaAndTypeSafeColumns(): Boolean[1]
{
   // Define a table schema
   let userSchema = ^TableSchema<Any>(
      name = 'users',
      columns = newMap([
         pair('id', Integer), 
         pair('name', String), 
         pair('email', String),
         pair('created at', DateTime)
      ])
   );
   
   // Create a table with schema
   let usersTable = tableWithSchema('users', $userSchema);
   
   // Test valid column references
   let validColSpec = ~($userSchema, 'id');
   let validColSpecQuoted = ~($userSchema, 'created at', true);
   let validColSpecArray = ~($userSchema, ['id', 'name', 'email']);
   
   // Test select with type-safe columns
   let df = select([
      as(validColSpec, 'id'),
      as(validColSpecQuoted, 'created_at')
   ])->from($usersTable);
   
   // Generate SQL for Snowflake and verify
   let snowflakeSQL = $df->generateSnowflakeSQL();
   assertEquals('SELECT id AS id, "created at" AS created_at\nFROM users', $snowflakeSQL);
   
   // Generate SQL for DuckDB and verify
   let duckdbSQL = $df->generateDuckDBSQL();
   assertEquals('SELECT id AS id, "created at" AS created_at\nFROM users', $duckdbSQL);
   
   // Test select with array of columns
   let dfArray = select(validColSpecArray)->from($usersTable);
   
   // Generate SQL for Snowflake and verify
   let snowflakeSQLArray = $dfArray->generateSnowflakeSQL();
   assertEquals('SELECT id, name, email\nFROM users', $snowflakeSQLArray);
   
   // Generate SQL for DuckDB and verify
   let duckdbSQLArray = $dfArray->generateDuckDBSQL();
   assertEquals('SELECT id, name, email\nFROM users', $duckdbSQLArray);
   
   true;
}

// Test WITH clause
function <<test.Test>> meta::pure::dsl::tests::testWithClause(): Boolean[1]
{
   // Define a table schema
   let employeeSchema = ^TableSchema<Any>(
      name = 'employees',
      columns = newMap([
         pair('name', String), 
         pair('department', String),
         pair('salary', Decimal)
      ])
   );
   
   // Create a table with schema
   let employeesTable = tableWithSchema('employees', $employeeSchema);
   
   // Define CTE and main query
   let employeesCte = cte('emp_cte', 
      select([
         as(~($employeeSchema, 'name'), 'name'),
         as(~($employeeSchema, 'department'), 'department'),
         as(~($employeeSchema, 'salary'), 'salary')
      ])
      ->from($employeesTable)
      ->where(eq(~($employeeSchema, 'salary'), literal(50000)))
   );
   
   let mainQuery = select([
      as(col('e', 'name'), 'name'),
      as(col('e', 'department'), 'department')
   ])
   ->from(tableAs('emp_cte', 'e'))
   ->with($employeesCte);
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'WITH emp_cte AS (SELECT name AS name, department AS department, salary AS salary\nFROM employees\nWHERE (salary = 50000))\nSELECT e.name AS name, e.department AS department\nFROM emp_cte AS e';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'WITH emp_cte AS (SELECT name AS name, department AS department, salary AS salary\nFROM employees\nWHERE (salary = 50000))\nSELECT e.name AS name, e.department AS department\nFROM emp_cte AS e';
   
   assertEquals($expectedSnowflake, $mainQuery->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $mainQuery->generateDuckDBSQL());
   
   true;
}

// Test recursive WITH clause
function <<test.Test>> meta::pure::dsl::tests::testRecursiveWithClause(): Boolean[1]
{
   // Define a table schema for employees with hierarchical structure
   let employeeSchema = ^TableSchema<Any>(
      name = 'employees',
      columns = newMap([
         pair('id', Integer),
         pair('name', String),
         pair('parent_id', Integer)
      ])
   );
   
   // Create a table with schema
   let employeesTable = tableWithSchema('employees', $employeeSchema);
   
   // Define recursive CTE and main query
   let hierarchyCte = recursiveCte('hierarchy', ['id', 'name', 'parent_id', 'level'],
      union(
         select([
            as(~($employeeSchema, 'id'), 'id'),
            as(~($employeeSchema, 'name'), 'name'),
            as(~($employeeSchema, 'parent_id'), 'parent_id'),
            as(literal(1), 'level')
         ])
         ->from($employeesTable)
         ->where(isNull(~($employeeSchema, 'parent_id'))),
         
         select([
            as(col('e', 'id'), 'id'),
            as(col('e', 'name'), 'name'),
            as(col('e', 'parent_id'), 'parent_id'),
            as(add(col('h', 'level'), literal(1)), 'level')
         ])
         ->from(tableAs('employees', 'e'))
         ->join(tableAs('hierarchy', 'h'), eq(col('e', 'parent_id'), col('h', 'id')))
      )
   );
   
   let mainQuery = select([
      as(col('h', 'id'), 'id'),
      as(col('h', 'name'), 'name'),
      as(col('h', 'level'), 'level')
   ])
   ->from(tableAs('hierarchy', 'h'))
   ->orderBy([asc(col('h', 'level'))])
   ->with($hierarchyCte);
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'WITH RECURSIVE hierarchy(id, name, parent_id, level) AS (SELECT id AS id, name AS name, parent_id AS parent_id, 1 AS level\nFROM employees\nWHERE (parent_id IS NULL)\nUNION ALL\nSELECT e.id AS id, e.name AS name, e.parent_id AS parent_id, (h.level + 1) AS level\nFROM employees AS e INNER JOIN hierarchy AS h ON (e.parent_id = h.id))\nSELECT h.id AS id, h.name AS name, h.level AS level\nFROM hierarchy AS h\nORDER BY h.level ASC';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'WITH RECURSIVE hierarchy(id, name, parent_id, level) AS (SELECT id AS id, name AS name, parent_id AS parent_id, 1 AS level\nFROM employees\nWHERE (parent_id IS NULL)\nUNION ALL\nSELECT e.id AS id, e.name AS name, e.parent_id AS parent_id, (h.level + 1) AS level\nFROM employees AS e INNER JOIN hierarchy AS h ON (e.parent_id = h.id))\nSELECT h.id AS id, h.name AS name, h.level AS level\nFROM hierarchy AS h\nORDER BY h.level ASC';
   
   assertEquals($expectedSnowflake, $mainQuery->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $mainQuery->generateDuckDBSQL());
   
   true;
}

// Test PIVOT
function <<test.Test>> meta::pure::dsl::tests::testPivot(): Boolean[1]
{
   // Define a table schema for sales data
   let salesSchema = ^TableSchema<Any>(
      name = 'sales',
      columns = newMap([
         pair('region', String),
         pair('month', String),
         pair('amount', Decimal)
      ])
   );
   
   // Create a table with schema
   let salesTable = tableWithSchema('sales', $salesSchema);
   
   // Create a query with PIVOT
   let query = select([
      as(col('region'), 'region'),
      as(col('Jan'), 'Jan'),
      as(col('Feb'), 'Feb'),
      as(col('Mar'), 'Mar')
   ])->from(
      pivot(
         $salesTable,
         ~($salesSchema, 'month'),
         sum(~($salesSchema, 'amount')),
         [literal('Jan'), literal('Feb'), literal('Mar')]
      )
   );
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'SELECT region AS region, Jan AS Jan, Feb AS Feb, Mar AS Mar\nFROM sales PIVOT(SUM(amount) FOR month IN (\'Jan\', \'Feb\', \'Mar\'))';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'SELECT region AS region, Jan AS Jan, Feb AS Feb, Mar AS Mar\nFROM sales PIVOT(SUM(amount) FOR month IN (\'Jan\', \'Feb\', \'Mar\'))';
   
   assertEquals($expectedSnowflake, $query->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $query->generateDuckDBSQL());
   
   true;
}

// Test UNPIVOT
function <<test.Test>> meta::pure::dsl::tests::testUnpivot(): Boolean[1]
{
   // Define a table schema for quarterly sales data
   let quarterlySalesSchema = ^TableSchema<Any>(
      name = 'quarterly_sales',
      columns = newMap([
         pair('region', String),
         pair('Q1', Decimal),
         pair('Q2', Decimal),
         pair('Q3', Decimal),
         pair('Q4', Decimal)
      ])
   );
   
   // Create a table with schema
   let quarterlySalesTable = tableWithSchema('quarterly_sales', $quarterlySalesSchema);
   
   // Create a query with UNPIVOT
   let query = select([
      as(col('region'), 'region'),
      as(col('quarter'), 'quarter'),
      as(col('amount'), 'amount')
   ])->from(
      unpivot(
         $quarterlySalesTable,
         [~($quarterlySalesSchema, 'Q1'), ~($quarterlySalesSchema, 'Q2'), 
          ~($quarterlySalesSchema, 'Q3'), ~($quarterlySalesSchema, 'Q4')],
         'quarter',
         'amount'
      )
   );
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'SELECT region AS region, quarter AS quarter, amount AS amount\nFROM quarterly_sales UNPIVOT(amount FOR quarter IN (Q1, Q2, Q3, Q4))';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'SELECT region AS region, quarter AS quarter, amount AS amount\nFROM quarterly_sales UNPIVOT(amount FOR quarter IN (Q1, Q2, Q3, Q4))';
   
   assertEquals($expectedSnowflake, $query->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $query->generateDuckDBSQL());
   
   true;
}

// Test GROUP BY CUBE
function <<test.Test>> meta::pure::dsl::tests::testGroupByCube(): Boolean[1]
{
   // Define a table schema for sales data
   let salesSchema = ^TableSchema<Any>(
      name = 'sales',
      columns = newMap([
         pair('region', String),
         pair('product', String),
         pair('sales_amount', Decimal)
      ])
   );
   
   // Create a table with schema
   let salesTable = tableWithSchema('sales', $salesSchema);
   
   // Create a query with GROUP BY CUBE
   let query = select([
      as(~($salesSchema, 'region'), 'region'),
      as(~($salesSchema, 'product'), 'product'),
      as(sum(~($salesSchema, 'sales_amount')), 'total_sales')
   ])->from($salesTable)
     ->groupByCube([~($salesSchema, 'region'), ~($salesSchema, 'product')]);
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'SELECT region AS region, product AS product, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY CUBE (region, product)';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'SELECT region AS region, product AS product, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY CUBE (region, product)';
   
   assertEquals($expectedSnowflake, $query->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $query->generateDuckDBSQL());
   
   true;
}

// Test GROUP BY ROLLUP
function <<test.Test>> meta::pure::dsl::tests::testGroupByRollup(): Boolean[1]
{
   // Define a table schema for sales data
   let salesSchema = ^TableSchema<Any>(
      name = 'sales',
      columns = newMap([
         pair('region', String),
         pair('product', String),
         pair('year', Integer),
         pair('sales_amount', Decimal)
      ])
   );
   
   // Create a table with schema
   let salesTable = tableWithSchema('sales', $salesSchema);
   
   // Create a query with GROUP BY ROLLUP
   let query = select([
      as(~($salesSchema, 'region'), 'region'),
      as(~($salesSchema, 'product'), 'product'),
      as(~($salesSchema, 'year'), 'year'),
      as(sum(~($salesSchema, 'sales_amount')), 'total_sales')
   ])->from($salesTable)
     ->groupByRollup([~($salesSchema, 'region'), ~($salesSchema, 'product'), ~($salesSchema, 'year')]);
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'SELECT region AS region, product AS product, year AS year, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY ROLLUP (region, product, year)';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'SELECT region AS region, product AS product, year AS year, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY ROLLUP (region, product, year)';
   
   assertEquals($expectedSnowflake, $query->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $query->generateDuckDBSQL());
   
   true;
}

// Test GROUP BY GROUPING SETS
function <<test.Test>> meta::pure::dsl::tests::testGroupByGroupingSets(): Boolean[1]
{
   // Define a table schema for sales data
   let salesSchema = ^TableSchema<Any>(
      name = 'sales',
      columns = newMap([
         pair('region', String),
         pair('product', String),
         pair('year', Integer),
         pair('sales_amount', Decimal)
      ])
   );
   
   // Create a table with schema
   let salesTable = tableWithSchema('sales', $salesSchema);
   
   // Create a query with GROUP BY GROUPING SETS
   let query = select([
      as(~($salesSchema, 'region'), 'region'),
      as(~($salesSchema, 'product'), 'product'),
      as(~($salesSchema, 'year'), 'year'),
      as(sum(~($salesSchema, 'sales_amount')), 'total_sales')
   ])->from($salesTable)
     ->groupByGroupingSets([
        groupingSet([~($salesSchema, 'region')]),
        groupingSet([~($salesSchema, 'product')]),
        groupingSet([~($salesSchema, 'region'), ~($salesSchema, 'product')]),
        groupingSet([~($salesSchema, 'region'), ~($salesSchema, 'year')])
     ]);
   
   // Expected SQL for Snowflake
   let expectedSnowflake = 'SELECT region AS region, product AS product, year AS year, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY GROUPING SETS ((region), (product), (region, product), (region, year))';
   
   // Expected SQL for DuckDB
   let expectedDuckDB = 'SELECT region AS region, product AS product, year AS year, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY GROUPING SETS ((region), (product), (region, product), (region, year))';
   
   assertEquals($expectedSnowflake, $query->generateSnowflakeSQL()) &&
   assertEquals($expectedDuckDB, $query->generateDuckDBSQL());
   
   true;
}
