// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;
import meta::pure::dsl::dataframe::metamodel::column::*;

/**
 * Core DataFrame DSL for modeling SQL SELECT statements
 * This DSL provides a unified interface for creating SQL queries that can be
 * executed against Snowflake, DuckDB, and BigQuery databases.
 */

// Core DataFrame metamodel
Class meta::pure::dsl::dataframe::metamodel::DataFrame
{
   columns : Column[*];
   source : Source[0..1];
   filter : FilterCondition[0..1];
   groupBy : GroupByClause[0..1];
   having : FilterCondition[0..1];
   orderBy : OrderByClause[*];
   limit : Integer[0..1];
   offset : Integer[0..1];
   distinct : Boolean[0..1];
   ctes : CommonTableExpression[*];
   qualify : FilterCondition[0..1];
}

;// Column representation
Class meta::pure::dsl::dataframe::metamodel::Column
{
   name : String[1];
   alias : String[0..1];
}

;// Abstract base class for all columns
Class meta::pure::dsl::dataframe::metamodel::ColumnReference extends Column
{
   tableName : String[0..1];
}

;// Literal column
Class meta::pure::dsl::dataframe::metamodel::LiteralColumn extends Column
{
   value : Any[1];
}

;// Function column
Class meta::pure::dsl::dataframe::metamodel::FunctionColumn extends Column
{
   name : String[1];
   arguments : Column[*];
}

;// Case column
Class meta::pure::dsl::dataframe::metamodel::CaseColumn extends Column
{
   condition : Column[0..1];
   whenClauses : WhenClause[*];
   elseResult : Column[0..1];
}

;// When clause for CASE expressions
Class meta::pure::dsl::dataframe::metamodel::WhenClause
{
   condition : Column[1];
   result : Column[1];
}

;// Window function column
Class meta::pure::dsl::dataframe::metamodel::WindowFunctionColumn extends Column
{
   function : FunctionColumn[1];
   partitionBy : Column[*];
   orderBy : OrderByClause[*];
   frameClause : FrameClause[0..1];
}

;// Frame clause for window functions
Class meta::pure::dsl::dataframe::metamodel::FrameClause
{
   type : FrameType[1];
   start : FrameBoundary[1];
   startOffset : Integer[0..1];
   end : FrameBoundary[1];
   endOffset : Integer[0..1];
}

;// Frame types
Enum meta::pure::dsl::dataframe::metamodel::FrameType
{
   ROWS,
   RANGE
}

;// Frame boundary types
Enum meta::pure::dsl::dataframe::metamodel::FrameBoundary
{
   UNBOUNDED_PRECEDING,
   CURRENT_ROW,
   UNBOUNDED_FOLLOWING,
   PRECEDING,
   FOLLOWING
}

;// Subquery column
Class meta::pure::dsl::dataframe::metamodel::SubqueryColumn extends Column
{
   query : DataFrame[1];
}

;// PIVOT column
Class meta::pure::dsl::dataframe::metamodel::PivotColumn extends Column
{
   aggregateFunction : FunctionColumn[1];
   pivotColumn : Column[1];
   pivotValues : LiteralColumn[*];
}

;// UNPIVOT column
Class meta::pure::dsl::dataframe::metamodel::UnpivotColumn extends Column
{
   nameColumn : String[1];
   valueColumn : String[1];
   columns : Column[*];
   includeNulls : Boolean[0..1];
}

;// Data source (table, subquery, etc.)
Class meta::pure::dsl::dataframe::metamodel::Source
{
}

;// Table source
Class meta::pure::dsl::dataframe::metamodel::TableSource extends Source
{
   name : String[1];
   schema : String[0..1];
   alias : String[0..1];
   tableSchema : TableSchema<Any>[0..1]; // Optional reference to table schema
}

;// Common Table Expression (CTE) for WITH clause
Class meta::pure::dsl::dataframe::metamodel::CommonTableExpression
{
   name : String[1];
   columns : String[*];
   query : Any[1]; // Can be DataFrame or String
   isRecursive : Boolean[0..1];
}

;// Join source
Class meta::pure::dsl::dataframe::metamodel::JoinSource extends Source
{
   left : Source[1];
   right : Source[1];
   type : JoinType[1];
   condition : Column[1];
}

;// Join types
Enum meta::pure::dsl::dataframe::metamodel::JoinType
{
   INNER,
   LEFT,
   RIGHT,
   FULL,
   CROSS
}

;// Subquery source
Class meta::pure::dsl::dataframe::metamodel::SubquerySource extends Source
{
   query : DataFrame[1];
   alias : String[0..1];
}

;// PIVOT source
Class meta::pure::dsl::dataframe::metamodel::PivotSource extends Source
{
   source : Source[1];
   aggregateFunction : FunctionColumn[1];
   pivotColumn : Column[1];
   pivotValues : Column[*];
   alias : String[0..1];
}

;// UNPIVOT source
Class meta::pure::dsl::dataframe::metamodel::UnpivotSource extends Source
{
   source : Source[1];
   nameColumn : String[1];
   valueColumn : String[1];
   columns : Column[*];
   includeNulls : Boolean[0..1];
   alias : String[0..1];
}

;// LATERAL JOIN source
Class meta::pure::dsl::dataframe::metamodel::LateralJoinSource extends Source
{
   left : Source[1];
   right : DataFrame[1];
   type : JoinType[1];
   condition : Column[0..1];
   alias : String[0..1];
}

;// Filter condition
Class meta::pure::dsl::dataframe::metamodel::FilterCondition
{
}

;// Group by clause
Class meta::pure::dsl::dataframe::metamodel::GroupByClause
{
   columns : Column[*];
   type : GroupByType[0..1];
   groupingSets : GroupingSet[*];
}

;// Grouping set for GROUPING SETS
Class meta::pure::dsl::dataframe::metamodel::GroupingSet
{
   columns : Column[*];
}

;// Group by types
Enum meta::pure::dsl::dataframe::metamodel::GroupByType
{
   STANDARD,
   CUBE,
   ROLLUP
}

;// Order by clause
Class meta::pure::dsl::dataframe::metamodel::OrderByClause
{
   column : Column[1];
   direction : SortDirection[1];
   nulls : NullsOrder[0..1];
}

;// Sort direction
Enum meta::pure::dsl::dataframe::metamodel::SortDirection
{
   ASC,
   DESC
}

<<<<<<< HEAD
;// Nulls order
Enum meta::pure::dsl::dataframe::metamodel::NullsOrder
{
   FIRST,
   LAST
}

// Column specification types for type-safe operations
Class meta::pure::dsl::dataframe::metamodel::column::ColSpec<T>
{
   name: String[1];
   tableSchema: TableSchema<T>[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::column::ColSpecArray<T>
{
   names: String[*];
   tableSchema: TableSchema<T>[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::column::FuncColSpec<F, Z>
{
   name: String[1];
   func: F[1];
}

Class meta::pure::dsl::dataframe::metamodel::column::FuncColSpecArray<F, Z>
{
   specs: FuncColSpec<F, Z>[*];
}

// For aggregation functions
Class meta::pure::dsl::dataframe::metamodel::column::AggColSpec<K, V, R>
{
   name: String[1];
   keyFunc: K[1];
   valueFunc: V[1];
}

// Window specification for window functions
Class meta::pure::dsl::dataframe::metamodel::column::WindowSpec
{
   partitionBy: String[*];
   orderBy: String[*];
}

// Table schema representation with column definitions
Class meta::pure::dsl::dataframe::metamodel::TableSchema<T>
{
   name: String[1];
   columns: Map<String, Type>[1];
}

// Aggregate functions
Class meta::pure::dsl::dataframe::metamodel::AggregateFunction extends FunctionExpression
>>>>>>> devin/1742617802-type-safe-dsl
{
   FIRST,
   LAST
}

<<<<<<< HEAD
// Tilde notation functions for column references
function meta::pure::dsl::dataframe::~(name:String[1]):ColSpec<Any>[1]
{
    ^ColSpec<Any>(name=$name);
}

function meta::pure::dsl::dataframe::~(names:String[*]):ColSpecArray<Any>[1]
{
    ^ColSpecArray<Any>(names=$names);
}

// Table-aware tilde notation for single column reference
function meta::pure::dsl::dataframe::~<T>(schema: TableSchema<T>[1], name: String[1]): ColSpec<T>[1]
{
   // Validate column exists in schema
   if($schema.columns->containsKey($name),
      ^ColSpec<T>(name = $name, tableSchema = $schema),
      error('Column "' + $name + '" not found in table schema "' + $schema.name + '"')
   );
}

// Tilde notation for quoted column names (with spaces)
function meta::pure::dsl::dataframe::~<T>(schema: TableSchema<T>[1], name: String[1], quoted: Boolean[1]): ColSpec<T>[1]
{
   if($quoted, 
      // For quoted names, we don't need to look up directly
      ^ColSpec<T>(name = $name, tableSchema = $schema),
      // For unquoted names, validate it exists
      if($schema.columns->containsKey($name),
         ^ColSpec<T>(name = $name, tableSchema = $schema),
         error('Column "' + $name + '" not found in table schema "' + $schema.name + '"')
      )
   );
}

// Tilde notation for multiple column references
function meta::pure::dsl::dataframe::~<T>(schema: TableSchema<T>[1], names: String[*]): ColSpecArray<T>[1]
{
   // Validate all columns exist in schema
   let invalidColumns = $names->filter(n | !$schema.columns->containsKey($n));
   if($invalidColumns->isEmpty(),
      ^ColSpecArray<T>(names = $names, tableSchema = $schema),
      error('Columns [' + $invalidColumns->joinStrings(', ') + '] not found in table schema "' + $schema.name + '"')
   );
}

// Common aggregate functions
Class meta::pure::dsl::dataframe::metamodel::CountFunction extends AggregateFunction
>>>>>>> devin/1742617802-type-safe-dsl
{
   name : String[1];
   columns : String[*];
}

;// Database enum
Enum meta::pure::dsl::dataframe::Database
{
   SNOWFLAKE,
   DUCKDB,
   BIGQUERY
}

// Factory functions for creating DataFrame objects
function meta::pure::dsl::dataframe::newDataFrame(): DataFrame[1]
{
   ^DataFrame(columns = [], distinct = false)
}

<<<<<<< HEAD
// Type-safe select functions
function meta::pure::dsl::dataframe::select<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   // Create column references from ColSpecArray
   let colRefs = $cols.names->map(n | 
      ^ColumnReference(columnName = $n)
   );
   
   // Create columns with expressions
   let dfColumns = $colRefs->map(cr |
      ^Column(name = $cr.columnName, expression = $cr, alias = $cr.columnName)
   );
   
   ^DataFrame(
      columns = $dfColumns,
      source = $df.source,
      distinct = false
   );
}

function meta::pure::dsl::dataframe::select<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   // Create column reference
   let colRef = ^ColumnReference(columnName = $col.name);
   
   // Create column with expression
   let dfColumn = ^Column(name = $colRef.columnName, expression = $colRef, alias = $colRef.columnName);
   
   ^DataFrame(
      columns = [$dfColumn],
      source = $df.source,
      distinct = false
   );
}

function meta::pure::dsl::dataframe::select(columns: Column[*]): DataFrame[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^DataFrame(columns = $columns, distinct = false)
}

<<<<<<< HEAD
function meta::pure::dsl::dataframe::selectDistinct<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   let newColumns = $cols.names->map(n | $df.columns->filter(c | $c.name == $n)->toOne());
   ^DataFrame(
      columns = $newColumns,
      source = $df.source,
      distinct = true
   );
}

function meta::pure::dsl::dataframe::selectDistinct<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   let newColumn = $df.columns->filter(c | $c.name == $col.name)->toOne();
   ^DataFrame(
      columns = [$newColumn],
      source = $df.source,
      distinct = true
   );
}

function meta::pure::dsl::dataframe::selectDistinct(columns: Column[*]): DataFrame[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^DataFrame(columns = $columns, distinct = true)
}

;function meta::pure::dsl::dataframe::from(df: DataFrame[1], source: Source[1]);: DataFrame[1]
{
   ^$df(source = $source)
}

<<<<<<< HEAD
// Type-safe filter function
function meta::pure::dsl::dataframe::filter<T>(df: DataFrame[1], condition: Function<{T[1]->Boolean[1]}>[1]): DataFrame[1]
{
   ^$df(filter = $condition)
}

// Type-safe filter function with lambda expression
function meta::pure::dsl::dataframe::filter<T, Z>(df: DataFrame[1], tableSchema: TableSchema<T>[1], condition: Function<{T[1]->Boolean[1]}>[1]): DataFrame[1]
{
   // Validate condition against table schema
   ^$df(filter = $condition)
}

function meta::pure::dsl::dataframe::where(df: DataFrame[1], condition: FilterCondition[1]): DataFrame[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^$df(filter = $condition)
}

<<<<<<< HEAD
// Type-safe groupBy functions
function meta::pure::dsl::dataframe::groupBy<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   // Create column references from ColSpecArray
   let colRefs = $cols.names->map(n | ^ColumnReference(columnName = $n));
   
   ^$df(groupBy = ^GroupByClause(columns = $colRefs));
}

function meta::pure::dsl::dataframe::groupBy<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   // Create column reference
   let colRef = ^ColumnReference(columnName = $col.name);
   
   ^$df(groupBy = ^GroupByClause(columns = [$colRef]));
}

// Type-safe groupBy function with table schema validation
function meta::pure::dsl::dataframe::groupBy<T, Z>(df: DataFrame[1], tableSchema: TableSchema<T>[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   // Validate columns against table schema
   let invalidColumns = $cols.names->filter(n | !$tableSchema.columns->containsKey($n));
   if($invalidColumns->isEmpty(),
      {
         // Create column references from ColSpecArray
         let colRefs = $cols.names->map(n | ^ColumnReference(columnName = $n));
         
         ^$df(groupBy = ^GroupByClause(columns = $colRefs));
      },
      error('Columns [' + $invalidColumns->joinStrings(', ') + '] not found in table schema "' + $tableSchema.name + '"')
   );
}

function meta::pure::dsl::dataframe::groupBy(df: DataFrame[1], columns: Column[*]): DataFrame[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.STANDARD))
}

;function meta::pure::dsl::dataframe::groupByCube(df: DataFrame[1], columns: Column[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.CUBE))
}

;function meta::pure::dsl::dataframe::groupByRollup(df: DataFrame[1], columns: Column[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.ROLLUP))
}

;function meta::pure::dsl::dataframe::groupByGroupingSets(df: DataFrame[1], groupingSets: GroupingSet[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(groupingSets = $groupingSets))
}

;function meta::pure::dsl::dataframe::groupingSet(columns: Column[*]);: GroupingSet[1]
{
   ^GroupingSet(columns = $columns)
}

;function meta::pure::dsl::dataframe::having(df: DataFrame[1], condition: FilterCondition[1]);: DataFrame[1]
{
   ^$df(having = $condition)
}

<<<<<<< HEAD
;function meta::pure::dsl::dataframe::qualify(df: DataFrame[1], condition: FilterCondition[1]);: DataFrame[1]
{
   ^$df(qualify = $condition)
}

;function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]);: DataFrame[1]
||||||| 37e433a
function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]): DataFrame[1]
=======
// Type-safe orderBy functions
function meta::pure::dsl::dataframe::orderBy<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1], desc: Boolean[0..1]): DataFrame[1]
{
   let direction = if($desc->isNotEmpty() && $desc->toOne(), |SortDirection.DESC, |SortDirection.ASC);
   let clauses = $cols.names->map(n | ^OrderByClause(
      expression = ^ColumnReference(columnName = $n),
      direction = $direction
   ));
   ^$df(orderBy = $clauses);
}

function meta::pure::dsl::dataframe::orderBy<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1], desc: Boolean[0..1]): DataFrame[1]
{
   let direction = if($desc->isNotEmpty() && $desc->toOne(), |SortDirection.DESC, |SortDirection.ASC);
   let clause = ^OrderByClause(
      expression = ^ColumnReference(columnName = $col.name),
      direction = $direction
   );
   ^$df(orderBy = [$clause]);
}

function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]): DataFrame[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^$df(orderBy = $clauses)
}

;function meta::pure::dsl::dataframe::limit(df: DataFrame[1], limit: Integer[1]);: DataFrame[1]
{
   ^$df(limit = $limit)
}

;function meta::pure::dsl::dataframe::offset(df: DataFrame[1], offset: Integer[1]);: DataFrame[1]
{
   ^$df(offset = $offset)
}

<<<<<<< HEAD
;// Helper functions for column operations
function meta::pure::dsl::dataframe::col(name: String[1]);: ColumnReference[1]
||||||| 37e433a
// Helper functions for creating expressions
function meta::pure::dsl::dataframe::col(name: String[1]): ColumnReference[1]
=======
// Type-safe join functions
function meta::pure::dsl::dataframe::join<T, V>(left: DataFrame[1], right: DataFrame[1], joinType: JoinType[1], condition: Function<{T[1], V[1]->Boolean[1]}>[1]): DataFrame[1]
{
   ^JoinOperation(
      left = $left.source, 
      right = $right.source, 
      joinType = $joinType, 
      condition = $condition
   )->from($left.columns->concatenate($right.columns));
}

// Type-safe over functions for window operations
function meta::pure::dsl::dataframe::over<T>(cols: ColSpecArray<T>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = $cols.names,
      orderBy = []
   );
}

function meta::pure::dsl::dataframe::over<T>(col: ColSpec<T>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = [$col.name],
      orderBy = []
   );
}

function meta::pure::dsl::dataframe::over<T, Z>(cols: ColSpecArray<T>[1], orderByCols: ColSpecArray<Z>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = $cols.names,
      orderBy = $orderByCols.names
   );
}

function meta::pure::dsl::dataframe::over<T, Z>(col: ColSpec<T>[1], orderByCol: ColSpec<Z>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = [$col.name],
      orderBy = [$orderByCol.name]
   );
}

// Helper functions for creating expressions
function meta::pure::dsl::dataframe::col(name: String[1]): ColumnReference[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^ColumnReference(name = $name)
}

;function meta::pure::dsl::dataframe::col(tableName: String[1], columnName: String[1]);: ColumnReference[1]
{
   ^ColumnReference(name = $columnName, tableName = $tableName)
}

;function meta::pure::dsl::dataframe::literal(value: Any[1]);: LiteralColumn[1]
{
   ^LiteralColumn(name = 'literal_' + $value->toString(), value = $value)
}

;function meta::pure::dsl::dataframe::as(column: Column[1], alias: String[1]);: Column[1]
{
   ^$column(alias = $alias)
}

;// Helper functions for creating conditions
function meta::pure::dsl::dataframe::eq(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::neq(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'NOT_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::gt(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'GREATER_THAN', right = $right)
}

;function meta::pure::dsl::dataframe::lt(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'LESS_THAN', right = $right)
}

;function meta::pure::dsl::dataframe::gte(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'GREATER_THAN_OR_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::lte(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'LESS_THAN_OR_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::and(left: FilterCondition[1], right: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'AND', right = $right)
}

;function meta::pure::dsl::dataframe::or(left: FilterCondition[1], right: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'OR', right = $right)
}

;function meta::pure::dsl::dataframe::not(expr: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(operator = 'NOT', right = $expr)
}

;function meta::pure::dsl::dataframe::like(expr: Column[1], pattern: String[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'LIKE', right = ^LiteralColumn(name = 'pattern', value = $pattern))
}

;function meta::pure::dsl::dataframe::isNull(expr: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'IS_NULL');
}

;function meta::pure::dsl::dataframe::isNotNull(expr: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'IS_NOT_NULL');
}

;// Helper functions for creating data sources
function meta::pure::dsl::dataframe::table(name: String[1]);: TableSource[1]
{
   ^TableSource(name = $name);
}

;function meta::pure::dsl::dataframe::table(schema: String[1], name: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, schema = $schema);
}

;function meta::pure::dsl::dataframe::tableAs(name: String[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, alias = $alias);
}

;function meta::pure::dsl::dataframe::tableAs(schema: String[1], name: String[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, schema = $schema, alias = $alias);
}

<<<<<<< HEAD
;function meta::pure::dsl::dataframe::tableWithSchema<T>(name: String[1], schema: TableSchema<T>[1]);: TableSource[1]
||||||| 37e433a
function meta::pure::dsl::dataframe::join(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
=======
// Define a table with schema
function meta::pure::dsl::dataframe::tableWithSchema<T>(name: String[1], schema: TableSchema<T>[1]): TableReference[1]
{
   ^TableReference(tableName = $name, tableSchema = $schema);
}

// Define a table with schema and alias
function meta::pure::dsl::dataframe::tableWithSchemaAs<T>(name: String[1], schema: TableSchema<T>[1], alias: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, tableSchema = $schema, alias = $alias);
}

function meta::pure::dsl::dataframe::join(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^TableSource(name = $name, tableSchema = $schema);
}

;function meta::pure::dsl::dataframe::tableWithSchemaAs<T>(name: String[1], schema: TableSchema<T>[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, tableSchema = $schema, alias = $alias);
}

;// Join functions
function meta::pure::dsl::dataframe::join(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.INNER, condition = $condition);
}

;function meta::pure::dsl::dataframe::leftJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.LEFT, condition = $condition);
}

;function meta::pure::dsl::dataframe::rightJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.RIGHT, condition = $condition);
}

;function meta::pure::dsl::dataframe::fullJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.FULL, condition = $condition);
}

;function meta::pure::dsl::dataframe::crossJoin(left: Source[1], right: Source[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.CROSS, condition = ^LiteralColumn(name = 'true', value = true));
}

<<<<<<< HEAD
;// LATERAL JOIN functions
function meta::pure::dsl::dataframe::lateralJoin(left: Source[1], right: DataFrame[1], type: JoinType[1]);: LateralJoinSource[1]
||||||| 37e433a
function meta::pure::dsl::dataframe::sum(expr: Expression[1]): SumFunction[1]
=======
// Type-safe aggregate functions
function meta::pure::dsl::dataframe::sum<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>(
      name = 'sum_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->sum()}
   );
}

function meta::pure::dsl::dataframe::avg<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>(
      name = 'avg_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->average()}
   );
}

function meta::pure::dsl::dataframe::min<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>(
      name = 'min_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->min()}
   );
}

function meta::pure::dsl::dataframe::max<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>(
      name = 'max_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->max()}
   );
}

// Legacy functions for backward compatibility
function meta::pure::dsl::dataframe::sum(expr: Expression[1]): SumFunction[1]
>>>>>>> devin/1742617802-type-safe-dsl
{
   ^LateralJoinSource(left = $left, right = $right, type = $type);
}

;function meta::pure::dsl::dataframe::lateralJoin(left: Source[1], right: DataFrame[1], type: JoinType[1], condition: Column[1]);: LateralJoinSource[1]
{
   ^LateralJoinSource(left = $left, right = $right, type = $type, condition = $condition);
}

;// PIVOT and UNPIVOT functions
function meta::pure::dsl::dataframe::pivot(source: Source[1], pivotColumn: Column[1], valueColumn: Column[1], pivotValues: Column[*]);: PivotSource[1]
{
   ^PivotSource(source = $source, pivotColumn = $pivotColumn, aggregateFunction = ^FunctionColumn(name = 'MAX', arguments = [$valueColumn]), pivotValues = $pivotValues);
}

;function meta::pure::dsl::dataframe::pivotAs(source: Source[1], pivotColumn: Column[1], valueColumn: Column[1], pivotValues: Column[*], alias: String[1]);: PivotSource[1]
{
   ^PivotSource(source = $source, pivotColumn = $pivotColumn, aggregateFunction = ^FunctionColumn(name = 'MAX', arguments = [$valueColumn]), pivotValues = $pivotValues, alias = $alias);
}

;function meta::pure::dsl::dataframe::unpivot(source: Source[1], columns: Column[*], nameColumn: String[1], valueColumn: String[1]);: UnpivotSource[1]
{
   ^UnpivotSource(source = $source, columns = $columns, nameColumn = $nameColumn, valueColumn = $valueColumn, includeNulls = false);
}

;function meta::pure::dsl::dataframe::unpivotAs(source: Source[1], columns: Column[*], nameColumn: String[1], valueColumn: String[1], alias: String[1]);: UnpivotSource[1]
{
   ^UnpivotSource(source = $source, columns = $columns, nameColumn = $nameColumn, valueColumn = $valueColumn, includeNulls = false, alias = $alias);
}
<<<<<<< HEAD

;// Aggregate functions
function meta::pure::dsl::dataframe::count(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'COUNT', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::countDistinct(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'COUNT_DISTINCT', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::sum(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'SUM', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::avg(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'AVG', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::min(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'MIN', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::max(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'MAX', arguments = [$expr]);
}

;// Window functions
function meta::pure::dsl::dataframe::over(func: FunctionColumn[1], partitionBy: Column[*], orderBy: OrderByClause[*]);: WindowFunctionColumn[1]
{
   ^WindowFunctionColumn(name = $func.name + '_OVER', function = $func, partitionBy = $partitionBy, orderBy = $orderBy);
}

;// Helper functions for creating order by clauses
function meta::pure::dsl::dataframe::asc(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC);
}

;function meta::pure::dsl::dataframe::desc(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC);
}

;function meta::pure::dsl::dataframe::ascNullsFirst(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC, nulls = NullsOrder.FIRST);
}

;function meta::pure::dsl::dataframe::ascNullsLast(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC, nulls = NullsOrder.LAST);
}

;function meta::pure::dsl::dataframe::descNullsFirst(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC, nulls = NullsOrder.FIRST);
}

;function meta::pure::dsl::dataframe::descNullsLast(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC, nulls = NullsOrder.LAST);
}

;// WITH clause helper functions
function meta::pure::dsl::dataframe::with(df: DataFrame[1], cte: CommonTableExpression[1]);: DataFrame[1]
{
   ^$df(ctes = $df.ctes->add($cte));
}

;function meta::pure::dsl::dataframe::with(df: DataFrame[1], ctes: CommonTableExpression[*]);: DataFrame[1]
{
   ^$df(ctes = $df.ctes->concatenate($ctes));
}

;function meta::pure::dsl::dataframe::cte(name: String[1], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, query = $query, isRecursive = false);
}

;function meta::pure::dsl::dataframe::cte(name: String[1], columns: String[*], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, columns = $columns, query = $query, isRecursive = false);
}

;function meta::pure::dsl::dataframe::recursiveCte(name: String[1], columns: String[*], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, columns = $columns, query = $query, isRecursive = true);
}

;// SQL generation functions for different databases
function meta::pure::dsl::dataframe::generateSQL(df: DataFrame[1], database: Database[1]);: String[1]
{
   $database->match([
      SNOWFLAKE: {db | meta::pure::dsl::snowflake::generateSnowflakeSQL($df);},
      DUCKDB: {db | meta::pure::dsl::duckdb::generateDuckDBSQL($df);},
      BIGQUERY: {db | meta::pure::dsl::bigquery::generateBigQuerySQL($df);}
   ]);
}

;// Convenience functions for generating SQL for specific databases
function meta::pure::dsl::dataframe::generateSnowflakeSQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::snowflake::generateSnowflakeSQL($df);
}

;function meta::pure::dsl::dataframe::generateDuckDBSQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::duckdb::generateDuckDBSQL($df);
}

;function meta::pure::dsl::dataframe::generateBigQuerySQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::bigquery::generateBigQuerySQL($df);
}
;
||||||| bdea5bd
=======

// Window function helper functions
function meta::pure::dsl::dataframe::over(expr: Expression[1], window: Window[1]): WindowFunction[1]
{
   let functionName = $expr->getFunctionName();
   
   if($functionName == 'row_number')
   {
      ^RowNumberFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'rank')
   {
      ^RankFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'dense_rank')
   {
      ^DenseRankFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'lead' || $functionName == 'lag')
   {
      let params = $expr->getFunctionParameters();
      let valueExpr = $params->at(0);
      let offset = if($params->size() >= 2, |$params->at(1), |^LiteralExpression(value = 1));
      let defaultValue = if($params->size() >= 3, |$params->at(2), |^LiteralExpression(value = null));
      
      ^LeadLagFunction(functionName = $functionName, parameters = [$valueExpr], window = $window, offset = $offset, defaultValue = $defaultValue);
   }
   else if($functionName == 'first_value' || $functionName == 'last_value')
   {
      let params = $expr->getFunctionParameters();
      let valueExpr = $params->at(0);
      
      ^FirstLastValueFunction(functionName = $functionName, parameters = [$valueExpr], window = $window);
   }
   else
   {
      // Default to aggregate window function for sum, avg, min, max, count, etc.
      let params = if($expr->instanceOf(FunctionExpression), 
                     |$expr->cast(@FunctionExpression).parameters, 
                     |[$expr]);
      
      ^AggregateWindowFunction(functionName = $functionName, parameters = $params, window = $window);
   }
}

function meta::pure::dsl::dataframe::getFunctionName(expr: Expression[1]): String[1]
{
   if($expr->instanceOf(FunctionExpression),
      |$expr->cast(@FunctionExpression).functionName,
      |'');
}

function meta::pure::dsl::dataframe::getFunctionParameters(expr: Expression[1]): Expression[*]
{
   if($expr->instanceOf(FunctionExpression),
      |$expr->cast(@FunctionExpression).parameters,
      |[]);
}

function meta::pure::dsl::dataframe::partitionBy(columns: Expression[*]): Window[1]
{
   ^Window(partitionBy = $columns, orderBy = []);
}

function meta::pure::dsl::dataframe::orderBy(window: Window[1], clauses: OrderByClause[*]): Window[1]
{
   ^$window(orderBy = $clauses);
}

function meta::pure::dsl::dataframe::rowsUnboundedPreceding(window: Window[1]): Window[1]
{
   ^$window(
      frameType = WindowFrameType.ROWS, 
      frameStart = ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_PRECEDING),
      frameEnd = ^WindowFrameBound(type = WindowFrameBoundType.CURRENT_ROW)
   );
}

function meta::pure::dsl::dataframe::rowsBetween(window: Window[1], start: WindowFrameBound[1], end: WindowFrameBound[1]): Window[1]
{
   ^$window(frameType = WindowFrameType.ROWS, frameStart = $start, frameEnd = $end);
}

function meta::pure::dsl::dataframe::rangeBetween(window: Window[1], start: WindowFrameBound[1], end: WindowFrameBound[1]): Window[1]
{
   ^$window(frameType = WindowFrameType.RANGE, frameStart = $start, frameEnd = $end);
}

function meta::pure::dsl::dataframe::unboundedPreceding(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_PRECEDING);
}

function meta::pure::dsl::dataframe::unboundedFollowing(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_FOLLOWING);
}

function meta::pure::dsl::dataframe::currentRow(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.CURRENT_ROW);
}

function meta::pure::dsl::dataframe::preceding(offset: Integer[1]): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.PRECEDING, offset = $offset);
}

function meta::pure::dsl::dataframe::following(offset: Integer[1]): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.FOLLOWING, offset = $offset);
}

// Window function factory functions
function meta::pure::dsl::dataframe::rowNumber(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'row_number', parameters = []);
}

function meta::pure::dsl::dataframe::rank(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'rank', parameters = []);
}

function meta::pure::dsl::dataframe::denseRank(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'dense_rank', parameters = []);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1], offset: Integer[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr, literal($offset)]);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1], offset: Integer[1], defaultValue: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr, literal($offset), $defaultValue]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1], offset: Integer[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr, literal($offset)]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1], offset: Integer[1], defaultValue: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr, literal($offset), $defaultValue]);
}

function meta::pure::dsl::dataframe::firstValue(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'first_value', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lastValue(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'last_value', parameters = [$expr]);
}

// Aggregate function factory functions
function meta::pure::dsl::dataframe::sum(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'sum', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::avg(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'avg', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::min(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'min', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::max(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'max', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::count(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'count', parameters = [$expr]);
}
>>>>>>> master
