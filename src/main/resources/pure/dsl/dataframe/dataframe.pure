// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;
import meta::pure::dsl::dataframe::metamodel::column::*;

/**
 * Core DataFrame DSL for modeling SQL SELECT statements
 * This DSL provides a unified interface for creating SQL queries that can be
 * executed against both Snowflake and DuckDB databases.
 */

// Core DataFrame metamodel
Class meta::pure::dsl::dataframe::metamodel::DataFrame
{
   columns : Column[*];
   source : DataSource[0..1];
   filter : FilterCondition[0..1];
   groupBy : GroupByClause[0..1];
   having : FilterCondition[0..1];
   orderBy : OrderByClause[*];
   limit : Integer[0..1];
   offset : Integer[0..1];
   distinct : Boolean[0..1];
}

// Column representation
Class meta::pure::dsl::dataframe::metamodel::Column
{
   name : String[1];
   expression : Expression[1];
   alias : String[0..1];
}

// Abstract base class for all expressions
Class meta::pure::dsl::dataframe::metamodel::Expression
{
}

// Literal value expression
Class meta::pure::dsl::dataframe::metamodel::LiteralExpression extends Expression
{
   value : Any[1];
}

// Column reference expression
Class meta::pure::dsl::dataframe::metamodel::ColumnReference extends Expression
{
   columnName : String[1];
   tableAlias : String[0..1];
}

// Function call expression
Class meta::pure::dsl::dataframe::metamodel::FunctionExpression extends Expression
{
   functionName : String[1];
   parameters : Expression[*];
}

// Data source (table, subquery, etc.)
Class meta::pure::dsl::dataframe::metamodel::DataSource
{
}

// Table reference
Class meta::pure::dsl::dataframe::metamodel::TableReference extends DataSource
{
   tableName : String[1];
   schema : String[0..1];
   alias : String[0..1];
}

// Join operation
Class meta::pure::dsl::dataframe::metamodel::JoinOperation extends DataSource
{
   left : DataSource[1];
   right : DataSource[1];
   joinType : JoinType[1];
   condition : FilterCondition[1];
}

// Join types
Enum meta::pure::dsl::dataframe::metamodel::JoinType
{
   INNER,
   LEFT_OUTER,
   RIGHT_OUTER,
   FULL_OUTER,
   CROSS
}

// Subquery as a data source
Class meta::pure::dsl::dataframe::metamodel::SubquerySource extends DataSource
{
   dataFrame : DataFrame[1];
   alias : String[1];
}

// Filter condition
Class meta::pure::dsl::dataframe::metamodel::FilterCondition extends Expression
{
}

// Binary operation (e.g., =, >, <, etc.)
Class meta::pure::dsl::dataframe::metamodel::BinaryOperation extends FilterCondition
{
   left : Expression[1];
   operator : BinaryOperator[1];
   right : Expression[1];
}

// Binary operators
Enum meta::pure::dsl::dataframe::metamodel::BinaryOperator
{
   EQUALS,
   NOT_EQUALS,
   GREATER_THAN,
   LESS_THAN,
   GREATER_THAN_OR_EQUALS,
   LESS_THAN_OR_EQUALS,
   AND,
   OR,
   LIKE,
   IN,
   NOT_IN,
   IS_NULL,
   IS_NOT_NULL
}

// Unary operation (e.g., NOT)
Class meta::pure::dsl::dataframe::metamodel::UnaryOperation extends FilterCondition
{
   operator : UnaryOperator[1];
   expression : Expression[1];
}

// Unary operators
Enum meta::pure::dsl::dataframe::metamodel::UnaryOperator
{
   NOT
}

// Group by clause
Class meta::pure::dsl::dataframe::metamodel::GroupByClause
{
   columns : Expression[*];
}

// Order by clause
Class meta::pure::dsl::dataframe::metamodel::OrderByClause
{
   expression : Expression[1];
   direction : SortDirection[1];
}

// Sort direction
Enum meta::pure::dsl::dataframe::metamodel::SortDirection
{
   ASC,
   DESC
}

// Column specification types for type-safe operations
Class meta::pure::dsl::dataframe::metamodel::column::ColSpec<T>
{
   name: String[1];
}

Class meta::pure::dsl::dataframe::metamodel::column::ColSpecArray<T>
{
   names: String[*];
}

Class meta::pure::dsl::dataframe::metamodel::column::FuncColSpec<F, Z>
{
   name: String[1];
   func: F[1];
}

Class meta::pure::dsl::dataframe::metamodel::column::FuncColSpecArray<F, Z>
{
   specs: FuncColSpec<F, Z>[*];
}

// For aggregation functions
Class meta::pure::dsl::dataframe::metamodel::column::AggColSpec<K, V, R>
{
   name: String[1];
   keyFunc: K[1];
   valueFunc: V[1];
}

// Window specification for window functions
Class meta::pure::dsl::dataframe::metamodel::column::WindowSpec
{
   partitionBy: String[*];
   orderBy: String[*];
}

// Aggregate functions
Class meta::pure::dsl::dataframe::metamodel::AggregateFunction extends FunctionExpression
{
}

// Tilde notation functions for column references
function meta::pure::dsl::dataframe::~(name:String[1]):ColSpec<Any>[1]
{
    ^ColSpec<Any>(name=$name);
}

function meta::pure::dsl::dataframe::~(names:String[*]):ColSpecArray<Any>[1]
{
    ^ColSpecArray<Any>(names=$names);
}

// Common aggregate functions
Class meta::pure::dsl::dataframe::metamodel::CountFunction extends AggregateFunction
{
   distinct : Boolean[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::SumFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::AvgFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::MinFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::MaxFunction extends AggregateFunction
{
}

// Factory functions for creating DataFrame objects
function meta::pure::dsl::dataframe::newDataFrame(): DataFrame[1]
{
   ^DataFrame(columns = [], distinct = false)
}

// Type-safe select functions
function meta::pure::dsl::dataframe::select<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   let newColumns = $cols.names->map(n | $df.columns->filter(c | $c.name == $n)->toOne());
   ^DataFrame(
      columns = $newColumns,
      source = $df.source,
      distinct = false
   );
}

function meta::pure::dsl::dataframe::select<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   let newColumn = $df.columns->filter(c | $c.name == $col.name)->toOne();
   ^DataFrame(
      columns = [$newColumn],
      source = $df.source,
      distinct = false
   );
}

function meta::pure::dsl::dataframe::select(columns: Column[*]): DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = false)
}

function meta::pure::dsl::dataframe::selectDistinct<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   let newColumns = $cols.names->map(n | $df.columns->filter(c | $c.name == $n)->toOne());
   ^DataFrame(
      columns = $newColumns,
      source = $df.source,
      distinct = true
   );
}

function meta::pure::dsl::dataframe::selectDistinct<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   let newColumn = $df.columns->filter(c | $c.name == $col.name)->toOne();
   ^DataFrame(
      columns = [$newColumn],
      source = $df.source,
      distinct = true
   );
}

function meta::pure::dsl::dataframe::selectDistinct(columns: Column[*]): DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = true)
}

function meta::pure::dsl::dataframe::from(df: DataFrame[1], source: DataSource[1]): DataFrame[1]
{
   ^$df(source = $source)
}

// Type-safe filter function
function meta::pure::dsl::dataframe::filter<T>(df: DataFrame[1], condition: Function<{T[1]->Boolean[1]}>[1]): DataFrame[1]
{
   ^$df(filter = $condition)
}

function meta::pure::dsl::dataframe::where(df: DataFrame[1], condition: FilterCondition[1]): DataFrame[1]
{
   ^$df(filter = $condition)
}

// Type-safe groupBy functions
function meta::pure::dsl::dataframe::groupBy<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1]): DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $cols.names->map(n | ^ColumnReference(columnName = $n))))
}

function meta::pure::dsl::dataframe::groupBy<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1]): DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = [^ColumnReference(columnName = $col.name)]))
}

function meta::pure::dsl::dataframe::groupBy(df: DataFrame[1], columns: Expression[*]): DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns))
}

function meta::pure::dsl::dataframe::having(df: DataFrame[1], condition: FilterCondition[1]): DataFrame[1]
{
   ^$df(having = $condition)
}

// Type-safe orderBy functions
function meta::pure::dsl::dataframe::orderBy<T, Z>(df: DataFrame[1], cols: ColSpecArray<Z>[1], desc: Boolean[0..1]): DataFrame[1]
{
   let direction = if($desc->isNotEmpty() && $desc->toOne(), |SortDirection.DESC, |SortDirection.ASC);
   let clauses = $cols.names->map(n | ^OrderByClause(
      expression = ^ColumnReference(columnName = $n),
      direction = $direction
   ));
   ^$df(orderBy = $clauses);
}

function meta::pure::dsl::dataframe::orderBy<T, Z>(df: DataFrame[1], col: ColSpec<Z>[1], desc: Boolean[0..1]): DataFrame[1]
{
   let direction = if($desc->isNotEmpty() && $desc->toOne(), |SortDirection.DESC, |SortDirection.ASC);
   let clause = ^OrderByClause(
      expression = ^ColumnReference(columnName = $col.name),
      direction = $direction
   );
   ^$df(orderBy = [$clause]);
}

function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]): DataFrame[1]
{
   ^$df(orderBy = $clauses)
}

function meta::pure::dsl::dataframe::limit(df: DataFrame[1], limit: Integer[1]): DataFrame[1]
{
   ^$df(limit = $limit)
}

function meta::pure::dsl::dataframe::offset(df: DataFrame[1], offset: Integer[1]): DataFrame[1]
{
   ^$df(offset = $offset)
}

// Type-safe join functions
function meta::pure::dsl::dataframe::join<T, V>(left: DataFrame[1], right: DataFrame[1], joinType: JoinType[1], condition: Function<{T[1], V[1]->Boolean[1]}>[1]): DataFrame[1]
{
   ^JoinOperation(
      left = $left.source, 
      right = $right.source, 
      joinType = $joinType, 
      condition = $condition
   )->from($left.columns->concatenate($right.columns));
}

// Type-safe over functions for window operations
function meta::pure::dsl::dataframe::over<T>(cols: ColSpecArray<T>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = $cols.names,
      orderBy = []
   );
}

function meta::pure::dsl::dataframe::over<T>(col: ColSpec<T>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = [$col.name],
      orderBy = []
   );
}

function meta::pure::dsl::dataframe::over<T, Z>(cols: ColSpecArray<T>[1], orderByCols: ColSpecArray<Z>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = $cols.names,
      orderBy = $orderByCols.names
   );
}

function meta::pure::dsl::dataframe::over<T, Z>(col: ColSpec<T>[1], orderByCol: ColSpec<Z>[1]): WindowSpec[1]
{
   ^WindowSpec(
      partitionBy = [$col.name],
      orderBy = [$orderByCol.name]
   );
}

// Helper functions for creating expressions
function meta::pure::dsl::dataframe::col(name: String[1]): ColumnReference[1]
{
   ^ColumnReference(columnName = $name)
}

function meta::pure::dsl::dataframe::col(tableName: String[1], columnName: String[1]): ColumnReference[1]
{
   ^ColumnReference(columnName = $columnName, tableAlias = $tableName)
}

function meta::pure::dsl::dataframe::literal(value: Any[1]): LiteralExpression[1]
{
   ^LiteralExpression(value = $value)
}

function meta::pure::dsl::dataframe::as(expr: Expression[1], alias: String[1]): Column[1]
{
   ^Column(name = $alias, expression = $expr, alias = $alias)
}

// Helper functions for creating conditions
function meta::pure::dsl::dataframe::eq(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::neq(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.NOT_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::gt(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.GREATER_THAN, right = $right)
}

function meta::pure::dsl::dataframe::lt(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.LESS_THAN, right = $right)
}

function meta::pure::dsl::dataframe::gte(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.GREATER_THAN_OR_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::lte(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.LESS_THAN_OR_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::and(left: FilterCondition[1], right: FilterCondition[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.AND, right = $right)
}

function meta::pure::dsl::dataframe::or(left: FilterCondition[1], right: FilterCondition[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.OR, right = $right)
}

function meta::pure::dsl::dataframe::not(expr: FilterCondition[1]): UnaryOperation[1]
{
   ^UnaryOperation(operator = UnaryOperator.NOT, expression = $expr)
}

function meta::pure::dsl::dataframe::like(expr: Expression[1], pattern: String[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.LIKE, right = ^LiteralExpression(value = $pattern))
}

function meta::pure::dsl::dataframe::isNull(expr: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.IS_NULL, right = ^LiteralExpression(value = 'null'))
}

function meta::pure::dsl::dataframe::isNotNull(expr: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.IS_NOT_NULL, right = ^LiteralExpression(value = 'null'))
}

// Helper functions for creating data sources
function meta::pure::dsl::dataframe::table(name: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name)
}

function meta::pure::dsl::dataframe::table(schema: String[1], name: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, schema = $schema)
}

function meta::pure::dsl::dataframe::tableAs(name: String[1], alias: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, alias = $alias)
}

function meta::pure::dsl::dataframe::tableAs(schema: String[1], name: String[1], alias: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, schema = $schema, alias = $alias)
}

function meta::pure::dsl::dataframe::join(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.INNER, condition = $condition)
}

function meta::pure::dsl::dataframe::leftJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.LEFT_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::rightJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.RIGHT_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::fullJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.FULL_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::crossJoin(left: DataSource[1], right: DataSource[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.CROSS, condition = ^BinaryOperation(left = ^LiteralExpression(value = true), operator = BinaryOperator.EQUALS, right = ^LiteralExpression(value = true)))
}

// Helper functions for creating aggregate functions
function meta::pure::dsl::dataframe::count(expr: Expression[1]): CountFunction[1]
{
   ^CountFunction(functionName = 'count', parameters = [$expr], distinct = false)
}

function meta::pure::dsl::dataframe::countDistinct(expr: Expression[1]): CountFunction[1]
{
   ^CountFunction(functionName = 'count', parameters = [$expr], distinct = true)
}

// Type-safe aggregate functions
function meta::pure::dsl::dataframe::sum<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>(
      name = 'sum_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->sum()}
   );
}

function meta::pure::dsl::dataframe::avg<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Number[0..1]},Any>(
      name = 'avg_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->average()}
   );
}

function meta::pure::dsl::dataframe::min<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>(
      name = 'min_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->min()}
   );
}

function meta::pure::dsl::dataframe::max<T>(col: ColSpec<T>[1]): AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>[1]
{
   ^AggColSpec<{T[1]->Any[0..1]},{Any[*]->Any[0..1]},Any>(
      name = 'max_' + $col.name,
      keyFunc = {x:T[1] | $x->get($col.name)},
      valueFunc = {values:Any[*] | $values->max()}
   );
}

// Legacy functions for backward compatibility
function meta::pure::dsl::dataframe::sum(expr: Expression[1]): SumFunction[1]
{
   ^SumFunction(functionName = 'sum', parameters = [$expr])
}

function meta::pure::dsl::dataframe::avg(expr: Expression[1]): AvgFunction[1]
{
   ^AvgFunction(functionName = 'avg', parameters = [$expr])
}

function meta::pure::dsl::dataframe::min(expr: Expression[1]): MinFunction[1]
{
   ^MinFunction(functionName = 'min', parameters = [$expr])
}

function meta::pure::dsl::dataframe::max(expr: Expression[1]): MaxFunction[1]
{
   ^MaxFunction(functionName = 'max', parameters = [$expr])
}

// Helper functions for creating order by clauses
function meta::pure::dsl::dataframe::asc(expr: Expression[1]): OrderByClause[1]
{
   ^OrderByClause(expression = $expr, direction = SortDirection.ASC)
}

function meta::pure::dsl::dataframe::desc(expr: Expression[1]): OrderByClause[1]
{
   ^OrderByClause(expression = $expr, direction = SortDirection.DESC)
}
