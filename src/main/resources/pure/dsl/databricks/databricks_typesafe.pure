// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;
import meta::pure::dsl::dataframe::metamodel::column::*;
import meta::pure::dsl::databricks::*;

/**
 * Type-safe Databricks SQL generator for the DataFrame DSL
 * This module provides functions to convert DataFrame objects to Databricks SQL syntax
 * with type safety guarantees
 */

// Type-safe SQL generation for Databricks
function meta::pure::dsl::databricks::toDatabricksSQL<T>(df: DataFrame<T>[1]): String[1]
{
   meta::pure::dsl::databricks::generateDatabricksSQL($df);
}

// Type-safe column reference for Databricks
function meta::pure::dsl::databricks::col<T, Z>(spec: ColSpec<T>[1]): ColumnReference[1]
{
   ^ColumnReference(
      name = $spec.name,
      tableAlias = if($spec.tableSchema->isEmpty(), [], [$spec.tableSchema->toOne().name])
   );
}

// Type-safe column array reference for Databricks
function meta::pure::dsl::databricks::cols<T, Z>(spec: ColSpecArray<T>[1]): ColumnReference[*]
{
   $spec.names->map(name | 
      ^ColumnReference(
         name = $name,
         tableAlias = if($spec.tableSchema->isEmpty(), [], [$spec.tableSchema->toOne().name])
      )
   );
}

// Type-safe function column for Databricks
function meta::pure::dsl::databricks::func<F, Z>(spec: FuncColSpec<F, Z>[1]): FunctionColumn[1]
{
   ^FunctionColumn(
      name = $spec.name,
      arguments = []
   );
}

// Type-safe function column array for Databricks
function meta::pure::dsl::databricks::funcs<F, Z>(spec: FuncColSpecArray<F, Z>[1]): FunctionColumn[*]
{
   $spec.specs->map(s | 
      ^FunctionColumn(
         name = $s.name,
         arguments = []
      )
   );
}

// Type-safe aggregation column for Databricks
function meta::pure::dsl::databricks::agg<K, V, R>(spec: AggColSpec<K, V, R>[1]): FunctionColumn[1]
{
   ^FunctionColumn(
      name = $spec.name,
      arguments = []
   );
}

// Type-safe window function for Databricks
function meta::pure::dsl::databricks::over<T, Z>(func: FunctionColumn[1], window: WindowSpec[1]): WindowFunctionColumn[1]
{
   ^WindowFunctionColumn(
      function = $func,
      partitionBy = $window.partitionBy->map(p | ^ColumnReference(name = $p)),
      orderBy = $window.orderBy->map(o | ^OrderByItem(column = ^ColumnReference(name = $o), direction = SortDirection.ASC))
   );
}

// Type-safe QUALIFY clause for Databricks (Databricks-specific)
function meta::pure::dsl::databricks::qualify<T>(df: DataFrame<T>[1], condition: Column[1]): DataFrame<T>[1]
{
   ^$df(qualify = $condition);
}

// Type-safe CLUSTER BY clause for Databricks (Databricks-specific)
function meta::pure::dsl::databricks::clusterBy<T>(df: DataFrame<T>[1], columns: Column[*]): DataFrame<T>[1]
{
   ^$df(clusterBy = $columns);
}
