// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;
import meta::pure::dsl::dataframe::metamodel::column::*;

// Main function to generate BigQuery SQL from a DataFrame
function meta::pure::dsl::bigquery::generateBigQuerySQL(df: DataFrame[1]): String[1]
{
   let withClause = generateWithClause($df);
   let selectClause = generateSelectClause($df);
   let fromClause = generateFromClause($df);
   let whereClause = generateWhereClause($df);
   let groupByClause = generateGroupByClause($df);
   let havingClause = generateHavingClause($df);
   let orderByClause = generateOrderByClause($df);
   let limitClause = generateLimitClause($df);
   
   $withClause + $selectClause + $fromClause + $whereClause + $groupByClause + $havingClause + $orderByClause + $limitClause;
}

// Generate the WITH clause
function <<access.private>> meta::pure::dsl::bigquery::generateWithClause(df: DataFrame[1]): String[1]
{
   if($df.ctes->isEmpty(), 
      '', 
      'WITH ' + $df.ctes->map(cte | 
         if($cte.isRecursive, 
            'RECURSIVE ', 
            '') + 
         $cte.name + ' AS (' + 
         if($cte.query->instanceOf(DataFrame), 
            meta::pure::dsl::bigquery::generateBigQuerySQL($cte.query->cast(@DataFrame)), 
            $cte.query->cast(@String)) + 
         ')'
      )->joinStrings(',\n') + '\n');
}

// Generate the SELECT clause
function <<access.private>> meta::pure::dsl::bigquery::generateSelectClause(df: DataFrame[1]): String[1]
{
   'SELECT ' + 
   if($df.distinct, 'DISTINCT ', '') + 
   if($df.columns->isEmpty(), 
      '*', 
      $df.columns->map(c | $c->generateBigQueryExpression() + if($c.alias->isEmpty(), '', ' AS ' + $c.alias->toOne()))->joinStrings(', '));
}

// Generate the FROM clause
function <<access.private>> meta::pure::dsl::bigquery::generateFromClause(df: DataFrame[1]): String[1]
{
   if($df.source->isEmpty(), 
      '', 
      '\nFROM ' + $df.source->toOne()->generateBigQuerySource());
}

// Generate the WHERE clause
function <<access.private>> meta::pure::dsl::bigquery::generateWhereClause(df: DataFrame[1]): String[1]
{
   if($df.filter->isEmpty(), 
      '', 
      '\nWHERE ' + $df.filter->toOne()->generateBigQueryExpression());
}

// Generate the GROUP BY clause
function <<access.private>> meta::pure::dsl::bigquery::generateGroupByClause(df: DataFrame[1]): String[1]
{
   if($df.groupBy->isEmpty() || $df.groupBy.columns->isEmpty(), 
      '', 
      '\nGROUP BY ' + 
      if($df.groupBy.type == GroupByType.STANDARD,
         $df.groupBy.columns->map(c | $c->generateBigQueryExpression())->joinStrings(', '),
         if($df.groupBy.type == GroupByType.CUBE,
            'CUBE(' + $df.groupBy.columns->map(c | $c->generateBigQueryExpression())->joinStrings(', ') + ')',
            if($df.groupBy.type == GroupByType.ROLLUP,
               'ROLLUP(' + $df.groupBy.columns->map(c | $c->generateBigQueryExpression())->joinStrings(', ') + ')',
               // GROUPING SETS
               'GROUPING SETS(' + $df.groupBy.groupingSets->map(gs | 
                  '(' + $gs->map(c | $c->generateBigQueryExpression())->joinStrings(', ') + ')'
               )->joinStrings(', ') + ')'
            )
         )
      )
   );
}

// Generate the HAVING clause
function <<access.private>> meta::pure::dsl::bigquery::generateHavingClause(df: DataFrame[1]): String[1]
{
   if($df.having->isEmpty(), 
      '', 
      '\nHAVING ' + $df.having->toOne()->generateBigQueryExpression());
}

// Generate the ORDER BY clause
function <<access.private>> meta::pure::dsl::bigquery::generateOrderByClause(df: DataFrame[1]): String[1]
{
   if($df.orderBy->isEmpty(), 
      '', 
      '\nORDER BY ' + $df.orderBy->map(o | 
         $o.column->generateBigQueryExpression() + 
         if($o.direction == SortDirection.ASC, '', ' DESC') + 
         if($o.nulls == NullsOrder.FIRST, ' NULLS FIRST', if($o.nulls == NullsOrder.LAST, ' NULLS LAST', ''))
      )->joinStrings(', '));
}

// Generate the LIMIT clause
function <<access.private>> meta::pure::dsl::bigquery::generateLimitClause(df: DataFrame[1]): String[1]
{
   if($df.limit->isEmpty(), 
      '', 
      '\nLIMIT ' + $df.limit->toOne()->toString());
}

// Generate BigQuery expression for a column
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryExpression(column: Column[1]): String[1]
{
   $column->match([
      c: ColumnReference[1] | $c.name,
      c: LiteralColumn[1] | generateBigQueryLiteral($c.value),
      c: FunctionColumn[1] | generateBigQueryFunction($c),
      c: CaseColumn[1] | generateBigQueryCase($c),
      c: WindowFunctionColumn[1] | generateBigQueryWindowFunction($c),
      c: SubqueryColumn[1] | '(' + meta::pure::dsl::bigquery::generateBigQuerySQL($c.query) + ')',
      c: PivotColumn[1] | generateBigQueryPivot($c),
      c: UnpivotColumn[1] | generateBigQueryUnpivot($c)
   ]);
}

// Generate BigQuery literal
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryLiteral(value: Any[1]): String[1]
{
   $value->match([
      s: String[1] | '\'' + $s + '\'',
      i: Integer[1] | $i->toString(),
      f: Float[1] | $f->toString(),
      d: Decimal[1] | $d->toString(),
      b: Boolean[1] | if($b, 'TRUE', 'FALSE'),
      d: Date[1] | 'DATE \'' + $d->toString() + '\'',
      t: DateTime[1] | 'TIMESTAMP \'' + $t->toString() + '\'',
      n: Null[1] | 'NULL'
   ]);
}

// Generate BigQuery function
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryFunction(func: FunctionColumn[1]): String[1]
{
   $func.name + '(' + $func.arguments->map(arg | $arg->generateBigQueryExpression())->joinStrings(', ') + ')';
}

// Generate BigQuery CASE expression
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryCase(caseCol: CaseColumn[1]): String[1]
{
   'CASE ' + 
   if($caseCol.condition->isEmpty(), 
      '', 
      $caseCol.condition->toOne()->generateBigQueryExpression() + ' ') + 
   $caseCol.whenClauses->map(wc | 
      'WHEN ' + $wc.condition->generateBigQueryExpression() + 
      ' THEN ' + $wc.result->generateBigQueryExpression()
   )->joinStrings(' ') + 
   if($caseCol.elseResult->isEmpty(), 
      '', 
      ' ELSE ' + $caseCol.elseResult->toOne()->generateBigQueryExpression()) + 
   ' END';
}

// Generate BigQuery window function
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryWindowFunction(windowFunc: WindowFunctionColumn[1]): String[1]
{
   $windowFunc.function->generateBigQueryExpression() + 
   ' OVER (' + 
   if($windowFunc.partitionBy->isEmpty(), 
      '', 
      'PARTITION BY ' + $windowFunc.partitionBy->map(p | $p->generateBigQueryExpression())->joinStrings(', ')) + 
   if($windowFunc.orderBy->isEmpty(), 
      '', 
      if($windowFunc.partitionBy->isEmpty(), '', ' ') + 
      'ORDER BY ' + $windowFunc.orderBy->map(o | 
         $o.column->generateBigQueryExpression() + 
         if($o.direction == SortDirection.ASC, '', ' DESC') + 
         if($o.nulls == NullsOrder.FIRST, ' NULLS FIRST', if($o.nulls == NullsOrder.LAST, ' NULLS LAST', ''))
      )->joinStrings(', ')) + 
   if($windowFunc.frameClause->isEmpty(), 
      '', 
      if($windowFunc.partitionBy->isEmpty() && $windowFunc.orderBy->isEmpty(), '', ' ') + 
      $windowFunc.frameClause->toOne().type->toString() + ' ' + 
      if($windowFunc.frameClause->toOne().start == FrameBoundary.UNBOUNDED_PRECEDING, 
         'UNBOUNDED PRECEDING', 
         if($windowFunc.frameClause->toOne().start == FrameBoundary.CURRENT_ROW, 
            'CURRENT ROW', 
            $windowFunc.frameClause->toOne().startOffset->toOne()->toString() + ' PRECEDING')) + 
      ' AND ' + 
      if($windowFunc.frameClause->toOne().end == FrameBoundary.UNBOUNDED_FOLLOWING, 
         'UNBOUNDED FOLLOWING', 
         if($windowFunc.frameClause->toOne().end == FrameBoundary.CURRENT_ROW, 
            'CURRENT ROW', 
            $windowFunc.frameClause->toOne().endOffset->toOne()->toString() + ' FOLLOWING'))) + 
   ')';
}

// Generate BigQuery PIVOT
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryPivot(pivot: PivotColumn[1]): String[1]
{
   'PIVOT(' + 
   $pivot.aggregateFunction->generateBigQueryExpression() + 
   ' FOR ' + $pivot.pivotColumn->generateBigQueryExpression() + 
   ' IN (' + $pivot.pivotValues->map(v | $v->generateBigQueryExpression())->joinStrings(', ') + ')' + 
   ')';
}

// Generate BigQuery UNPIVOT
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryUnpivot(unpivot: UnpivotColumn[1]): String[1]
{
   'UNPIVOT(' + 
   if($unpivot.includeNulls, 'INCLUDE NULLS ', '') + 
   $unpivot.valueColumn + ' FOR ' + $unpivot.nameColumn + 
   ' IN (' + $unpivot.columns->map(c | $c->generateBigQueryExpression())->joinStrings(', ') + ')' + 
   ')';
}

// Generate BigQuery source
function <<access.private>> meta::pure::dsl::bigquery::generateBigQuerySource(source: Source[1]): String[1]
{
   $source->match([
      s: TableSource[1] | $s.name + if($s.alias->isEmpty(), '', ' AS ' + $s.alias->toOne()),
      s: SubquerySource[1] | '(' + meta::pure::dsl::bigquery::generateBigQuerySQL($s.query) + ')' + if($s.alias->isEmpty(), '', ' AS ' + $s.alias->toOne()),
      s: JoinSource[1] | generateBigQueryJoin($s),
      s: PivotSource[1] | generateBigQueryPivotSource($s),
      s: UnpivotSource[1] | generateBigQueryUnpivotSource($s),
      s: LateralJoinSource[1] | generateBigQueryLateralJoin($s)
   ]);
}

// Generate BigQuery JOIN
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryJoin(join: JoinSource[1]): String[1]
{
   $join.left->generateBigQuerySource() + 
   ' ' + $join.type->toString() + ' JOIN ' + 
   $join.right->generateBigQuerySource() + 
   ' ON ' + $join.condition->generateBigQueryExpression();
}

// Generate BigQuery PIVOT source
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryPivotSource(pivot: PivotSource[1]): String[1]
{
   $pivot.source->generateBigQuerySource() + 
   ' PIVOT(' + 
   $pivot.aggregateFunction->generateBigQueryExpression() + 
   ' FOR ' + $pivot.pivotColumn->generateBigQueryExpression() + 
   ' IN (' + $pivot.pivotValues->map(v | $v->generateBigQueryExpression() + if($v.alias->isEmpty(), '', ' AS ' + $v.alias->toOne()))->joinStrings(', ') + ')' + 
   ')' + if($pivot.alias->isEmpty(), '', ' AS ' + $pivot.alias->toOne());
}

// Generate BigQuery UNPIVOT source
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryUnpivotSource(unpivot: UnpivotSource[1]): String[1]
{
   $unpivot.source->generateBigQuerySource() + 
   ' UNPIVOT(' + 
   if($unpivot.includeNulls, 'INCLUDE NULLS ', '') + 
   $unpivot.valueColumn + ' FOR ' + $unpivot.nameColumn + 
   ' IN (' + $unpivot.columns->map(c | $c->generateBigQueryExpression() + if($c.alias->isEmpty(), '', ' AS ' + $c.alias->toOne()))->joinStrings(', ') + ')' + 
   ')' + if($unpivot.alias->isEmpty(), '', ' AS ' + $unpivot.alias->toOne());
}

// Generate BigQuery LATERAL JOIN
function <<access.private>> meta::pure::dsl::bigquery::generateBigQueryLateralJoin(lateral: LateralJoinSource[1]): String[1]
{
   $lateral.left->generateBigQuerySource() + 
   ' ' + $lateral.type->toString() + ' JOIN ' + 
   'LATERAL (' + meta::pure::dsl::bigquery::generateBigQuerySQL($lateral.right) + ')' + 
   if($lateral.alias->isEmpty(), '', ' AS ' + $lateral.alias->toOne()) + 
   if($lateral.condition->isEmpty(), 
      '', 
      ' ON ' + $lateral.condition->toOne()->generateBigQueryExpression());
}

;// Add BigQuery as a supported database
function meta::pure::dsl::dataframe::toSQL(df: DataFrame[1], database: Database[1]);: String[1]
{
   $database->match([
      db: Database[1] | if($db == Database.SNOWFLAKE, 
                           meta::pure::dsl::snowflake::generateSnowflakeSQL($df),
                           if($db == Database.DUCKDB,
                              meta::pure::dsl::duckdb::generateDuckDBSQL($df),
                              if($db == Database.BIGQUERY,
                                 meta::pure::dsl::bigquery::generateBigQuerySQL($df),
                                 if($db == Database.DATABRICKS,
                                    meta::pure::dsl::databricks::generateDatabricksSQL($df),
                                    fail('Unsupported database: ' + $db->toString()); ''))))
   ]);
}
