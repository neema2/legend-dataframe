// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;

/**
 * Core DataFrame DSL for modeling SQL SELECT statements
 * This DSL provides a unified interface for creating SQL queries that can be
 * executed against Snowflake, DuckDB, and BigQuery databases.
 */

// Core DataFrame metamodel
Class meta::pure::dsl::dataframe::metamodel::DataFrame
{
   columns : Column[*];
   source : Source[0..1];
   filter : FilterCondition[0..1];
   groupBy : GroupByClause[0..1];
   having : FilterCondition[0..1];
   orderBy : OrderByClause[*];
   limit : Integer[0..1];
   offset : Integer[0..1];
   distinct : Boolean[0..1];
   ctes : CommonTableExpression[*];
   qualify : FilterCondition[0..1];
}

;// Column representation
Class meta::pure::dsl::dataframe::metamodel::Column
{
   name : String[1];
   alias : String[0..1];
}

;// Abstract base class for all columns
Class meta::pure::dsl::dataframe::metamodel::ColumnReference extends Column
{
   tableName : String[0..1];
}

;// Literal column
Class meta::pure::dsl::dataframe::metamodel::LiteralColumn extends Column
{
   value : Any[1];
}

;// Function column
Class meta::pure::dsl::dataframe::metamodel::FunctionColumn extends Column
{
   name : String[1];
   arguments : Column[*];
}

;// Case column
Class meta::pure::dsl::dataframe::metamodel::CaseColumn extends Column
{
   condition : Column[0..1];
   whenClauses : WhenClause[*];
   elseResult : Column[0..1];
}

;// When clause for CASE expressions
Class meta::pure::dsl::dataframe::metamodel::WhenClause
{
   condition : Column[1];
   result : Column[1];
}

;// Window function column
Class meta::pure::dsl::dataframe::metamodel::WindowFunctionColumn extends Column
{
   function : FunctionColumn[1];
   partitionBy : Column[*];
   orderBy : OrderByClause[*];
   frameClause : FrameClause[0..1];
}

;// Frame clause for window functions
Class meta::pure::dsl::dataframe::metamodel::FrameClause
{
   type : FrameType[1];
   start : FrameBoundary[1];
   startOffset : Integer[0..1];
   end : FrameBoundary[1];
   endOffset : Integer[0..1];
}

;// Frame types
Enum meta::pure::dsl::dataframe::metamodel::FrameType
{
   ROWS,
   RANGE
}

;// Frame boundary types
Enum meta::pure::dsl::dataframe::metamodel::FrameBoundary
{
   UNBOUNDED_PRECEDING,
   CURRENT_ROW,
   UNBOUNDED_FOLLOWING,
   PRECEDING,
   FOLLOWING
}

;// Subquery column
Class meta::pure::dsl::dataframe::metamodel::SubqueryColumn extends Column
{
   query : DataFrame[1];
}

;// PIVOT column
Class meta::pure::dsl::dataframe::metamodel::PivotColumn extends Column
{
   aggregateFunction : FunctionColumn[1];
   pivotColumn : Column[1];
   pivotValues : LiteralColumn[*];
}

;// UNPIVOT column
Class meta::pure::dsl::dataframe::metamodel::UnpivotColumn extends Column
{
   nameColumn : String[1];
   valueColumn : String[1];
   columns : Column[*];
   includeNulls : Boolean[0..1];
}

;// Data source (table, subquery, etc.)
Class meta::pure::dsl::dataframe::metamodel::Source
{
}

;// Table source
Class meta::pure::dsl::dataframe::metamodel::TableSource extends Source
{
   name : String[1];
   schema : String[0..1];
   alias : String[0..1];
   tableSchema : TableSchema<Any>[0..1]; // Optional reference to table schema
}

;// Common Table Expression (CTE) for WITH clause
Class meta::pure::dsl::dataframe::metamodel::CommonTableExpression
{
   name : String[1];
   columns : String[*];
   query : Any[1]; // Can be DataFrame or String
   isRecursive : Boolean[0..1];
}

;// Join source
Class meta::pure::dsl::dataframe::metamodel::JoinSource extends Source
{
   left : Source[1];
   right : Source[1];
   type : JoinType[1];
   condition : Column[1];
}

;// Join types
Enum meta::pure::dsl::dataframe::metamodel::JoinType
{
   INNER,
   LEFT,
   RIGHT,
   FULL,
   CROSS
}

;// Subquery source
Class meta::pure::dsl::dataframe::metamodel::SubquerySource extends Source
{
   query : DataFrame[1];
   alias : String[0..1];
}

;// PIVOT source
Class meta::pure::dsl::dataframe::metamodel::PivotSource extends Source
{
   source : Source[1];
   aggregateFunction : FunctionColumn[1];
   pivotColumn : Column[1];
   pivotValues : Column[*];
   alias : String[0..1];
}

;// UNPIVOT source
Class meta::pure::dsl::dataframe::metamodel::UnpivotSource extends Source
{
   source : Source[1];
   nameColumn : String[1];
   valueColumn : String[1];
   columns : Column[*];
   includeNulls : Boolean[0..1];
   alias : String[0..1];
}

;// LATERAL JOIN source
Class meta::pure::dsl::dataframe::metamodel::LateralJoinSource extends Source
{
   left : Source[1];
   right : DataFrame[1];
   type : JoinType[1];
   condition : Column[0..1];
   alias : String[0..1];
}

;// Filter condition
Class meta::pure::dsl::dataframe::metamodel::FilterCondition
{
}

;// Group by clause
Class meta::pure::dsl::dataframe::metamodel::GroupByClause
{
   columns : Column[*];
   type : GroupByType[0..1];
   groupingSets : GroupingSet[*];
}

;// Grouping set for GROUPING SETS
Class meta::pure::dsl::dataframe::metamodel::GroupingSet
{
   columns : Column[*];
}

;// Group by types
Enum meta::pure::dsl::dataframe::metamodel::GroupByType
{
   STANDARD,
   CUBE,
   ROLLUP
}

;// Order by clause
Class meta::pure::dsl::dataframe::metamodel::OrderByClause
{
   column : Column[1];
   direction : SortDirection[1];
   nulls : NullsOrder[0..1];
}

;// Sort direction
Enum meta::pure::dsl::dataframe::metamodel::SortDirection
{
   ASC,
   DESC
}

;// Nulls order
Enum meta::pure::dsl::dataframe::metamodel::NullsOrder
{
   FIRST,
   LAST
}

;// Table schema for type-safe operations
Class meta::pure::dsl::dataframe::metamodel::TableSchema<T>
{
   name : String[1];
   columns : String[*];
}

;// Database enum
Enum meta::pure::dsl::dataframe::Database
{
   SNOWFLAKE,
   DUCKDB,
   BIGQUERY
}

;// Factory functions for creating DataFrame objects
function meta::pure::dsl::dataframe::newDataFrame(): DataFrame[1]
{
   ^DataFrame(columns = [], distinct = false)
}

;function meta::pure::dsl::dataframe::select(columns: Column[*]);: DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = false)
}

;function meta::pure::dsl::dataframe::selectDistinct(columns: Column[*]);: DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = true)
}

;function meta::pure::dsl::dataframe::from(df: DataFrame[1], source: Source[1]);: DataFrame[1]
{
   ^$df(source = $source)
}

;function meta::pure::dsl::dataframe::where(df: DataFrame[1], condition: FilterCondition[1]);: DataFrame[1]
{
   ^$df(filter = $condition)
}

;function meta::pure::dsl::dataframe::groupBy(df: DataFrame[1], columns: Column[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.STANDARD))
}

;function meta::pure::dsl::dataframe::groupByCube(df: DataFrame[1], columns: Column[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.CUBE))
}

;function meta::pure::dsl::dataframe::groupByRollup(df: DataFrame[1], columns: Column[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns, type = GroupByType.ROLLUP))
}

;function meta::pure::dsl::dataframe::groupByGroupingSets(df: DataFrame[1], groupingSets: GroupingSet[*]);: DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(groupingSets = $groupingSets))
}

;function meta::pure::dsl::dataframe::groupingSet(columns: Column[*]);: GroupingSet[1]
{
   ^GroupingSet(columns = $columns)
}

;function meta::pure::dsl::dataframe::having(df: DataFrame[1], condition: FilterCondition[1]);: DataFrame[1]
{
   ^$df(having = $condition)
}

;function meta::pure::dsl::dataframe::qualify(df: DataFrame[1], condition: FilterCondition[1]);: DataFrame[1]
{
   ^$df(qualify = $condition)
}

;function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]);: DataFrame[1]
{
   ^$df(orderBy = $clauses)
}

;function meta::pure::dsl::dataframe::limit(df: DataFrame[1], limit: Integer[1]);: DataFrame[1]
{
   ^$df(limit = $limit)
}

;function meta::pure::dsl::dataframe::offset(df: DataFrame[1], offset: Integer[1]);: DataFrame[1]
{
   ^$df(offset = $offset)
}

;// Helper functions for column operations
function meta::pure::dsl::dataframe::col(name: String[1]);: ColumnReference[1]
{
   ^ColumnReference(name = $name)
}

;function meta::pure::dsl::dataframe::col(tableName: String[1], columnName: String[1]);: ColumnReference[1]
{
   ^ColumnReference(name = $columnName, tableName = $tableName)
}

;function meta::pure::dsl::dataframe::literal(value: Any[1]);: LiteralColumn[1]
{
   ^LiteralColumn(name = 'literal_' + $value->toString(), value = $value)
}

;function meta::pure::dsl::dataframe::as(column: Column[1], alias: String[1]);: Column[1]
{
   ^$column(alias = $alias)
}

;// Helper functions for creating conditions
function meta::pure::dsl::dataframe::eq(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::neq(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'NOT_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::gt(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'GREATER_THAN', right = $right)
}

;function meta::pure::dsl::dataframe::lt(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'LESS_THAN', right = $right)
}

;function meta::pure::dsl::dataframe::gte(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'GREATER_THAN_OR_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::lte(left: Column[1], right: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'LESS_THAN_OR_EQUALS', right = $right)
}

;function meta::pure::dsl::dataframe::and(left: FilterCondition[1], right: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'AND', right = $right)
}

;function meta::pure::dsl::dataframe::or(left: FilterCondition[1], right: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $left, operator = 'OR', right = $right)
}

;function meta::pure::dsl::dataframe::not(expr: FilterCondition[1]);: FilterCondition[1]
{
   ^FilterCondition(operator = 'NOT', right = $expr)
}

;function meta::pure::dsl::dataframe::like(expr: Column[1], pattern: String[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'LIKE', right = ^LiteralColumn(name = 'pattern', value = $pattern))
}

;function meta::pure::dsl::dataframe::isNull(expr: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'IS_NULL');
}

;function meta::pure::dsl::dataframe::isNotNull(expr: Column[1]);: FilterCondition[1]
{
   ^FilterCondition(left = $expr, operator = 'IS_NOT_NULL');
}

;// Helper functions for creating data sources
function meta::pure::dsl::dataframe::table(name: String[1]);: TableSource[1]
{
   ^TableSource(name = $name);
}

;function meta::pure::dsl::dataframe::table(schema: String[1], name: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, schema = $schema);
}

;function meta::pure::dsl::dataframe::tableAs(name: String[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, alias = $alias);
}

;function meta::pure::dsl::dataframe::tableAs(schema: String[1], name: String[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, schema = $schema, alias = $alias);
}

;function meta::pure::dsl::dataframe::tableWithSchema<T>(name: String[1], schema: TableSchema<T>[1]);: TableSource[1]
{
   ^TableSource(name = $name, tableSchema = $schema);
}

;function meta::pure::dsl::dataframe::tableWithSchemaAs<T>(name: String[1], schema: TableSchema<T>[1], alias: String[1]);: TableSource[1]
{
   ^TableSource(name = $name, tableSchema = $schema, alias = $alias);
}

;// Join functions
function meta::pure::dsl::dataframe::join(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.INNER, condition = $condition);
}

;function meta::pure::dsl::dataframe::leftJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.LEFT, condition = $condition);
}

;function meta::pure::dsl::dataframe::rightJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.RIGHT, condition = $condition);
}

;function meta::pure::dsl::dataframe::fullJoin(left: Source[1], right: Source[1], condition: Column[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.FULL, condition = $condition);
}

;function meta::pure::dsl::dataframe::crossJoin(left: Source[1], right: Source[1]);: JoinSource[1]
{
   ^JoinSource(left = $left, right = $right, type = JoinType.CROSS, condition = ^LiteralColumn(name = 'true', value = true));
}

;// LATERAL JOIN functions
function meta::pure::dsl::dataframe::lateralJoin(left: Source[1], right: DataFrame[1], type: JoinType[1]);: LateralJoinSource[1]
{
   ^LateralJoinSource(left = $left, right = $right, type = $type);
}

;function meta::pure::dsl::dataframe::lateralJoin(left: Source[1], right: DataFrame[1], type: JoinType[1], condition: Column[1]);: LateralJoinSource[1]
{
   ^LateralJoinSource(left = $left, right = $right, type = $type, condition = $condition);
}

;// PIVOT and UNPIVOT functions
function meta::pure::dsl::dataframe::pivot(source: Source[1], pivotColumn: Column[1], valueColumn: Column[1], pivotValues: Column[*]);: PivotSource[1]
{
   ^PivotSource(source = $source, pivotColumn = $pivotColumn, aggregateFunction = ^FunctionColumn(name = 'MAX', arguments = [$valueColumn]), pivotValues = $pivotValues);
}

;function meta::pure::dsl::dataframe::pivotAs(source: Source[1], pivotColumn: Column[1], valueColumn: Column[1], pivotValues: Column[*], alias: String[1]);: PivotSource[1]
{
   ^PivotSource(source = $source, pivotColumn = $pivotColumn, aggregateFunction = ^FunctionColumn(name = 'MAX', arguments = [$valueColumn]), pivotValues = $pivotValues, alias = $alias);
}

;function meta::pure::dsl::dataframe::unpivot(source: Source[1], columns: Column[*], nameColumn: String[1], valueColumn: String[1]);: UnpivotSource[1]
{
   ^UnpivotSource(source = $source, columns = $columns, nameColumn = $nameColumn, valueColumn = $valueColumn, includeNulls = false);
}

;function meta::pure::dsl::dataframe::unpivotAs(source: Source[1], columns: Column[*], nameColumn: String[1], valueColumn: String[1], alias: String[1]);: UnpivotSource[1]
{
   ^UnpivotSource(source = $source, columns = $columns, nameColumn = $nameColumn, valueColumn = $valueColumn, includeNulls = false, alias = $alias);
}

;// Aggregate functions
function meta::pure::dsl::dataframe::count(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'COUNT', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::countDistinct(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'COUNT_DISTINCT', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::sum(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'SUM', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::avg(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'AVG', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::min(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'MIN', arguments = [$expr]);
}

;function meta::pure::dsl::dataframe::max(expr: Column[1]);: FunctionColumn[1]
{
   ^FunctionColumn(name = 'MAX', arguments = [$expr]);
}

;// Window functions
function meta::pure::dsl::dataframe::over(func: FunctionColumn[1], partitionBy: Column[*], orderBy: OrderByClause[*]);: WindowFunctionColumn[1]
{
   ^WindowFunctionColumn(name = $func.name + '_OVER', function = $func, partitionBy = $partitionBy, orderBy = $orderBy);
}

;// Helper functions for creating order by clauses
function meta::pure::dsl::dataframe::asc(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC);
}

;function meta::pure::dsl::dataframe::desc(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC);
}

;function meta::pure::dsl::dataframe::ascNullsFirst(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC, nulls = NullsOrder.FIRST);
}

;function meta::pure::dsl::dataframe::ascNullsLast(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.ASC, nulls = NullsOrder.LAST);
}

;function meta::pure::dsl::dataframe::descNullsFirst(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC, nulls = NullsOrder.FIRST);
}

;function meta::pure::dsl::dataframe::descNullsLast(expr: Column[1]);: OrderByClause[1]
{
   ^OrderByClause(column = $expr, direction = SortDirection.DESC, nulls = NullsOrder.LAST);
}

;// WITH clause helper functions
function meta::pure::dsl::dataframe::with(df: DataFrame[1], cte: CommonTableExpression[1]);: DataFrame[1]
{
   ^$df(ctes = $df.ctes->add($cte));
}

;function meta::pure::dsl::dataframe::with(df: DataFrame[1], ctes: CommonTableExpression[*]);: DataFrame[1]
{
   ^$df(ctes = $df.ctes->concatenate($ctes));
}

;function meta::pure::dsl::dataframe::cte(name: String[1], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, query = $query, isRecursive = false);
}

;function meta::pure::dsl::dataframe::cte(name: String[1], columns: String[*], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, columns = $columns, query = $query, isRecursive = false);
}

;function meta::pure::dsl::dataframe::recursiveCte(name: String[1], columns: String[*], query: DataFrame[1]);: CommonTableExpression[1]
{
   ^CommonTableExpression(name = $name, columns = $columns, query = $query, isRecursive = true);
}

;// SQL generation functions for different databases
function meta::pure::dsl::dataframe::generateSQL(df: DataFrame[1], database: Database[1]);: String[1]
{
   $database->match([
      SNOWFLAKE: {db | meta::pure::dsl::snowflake::generateSnowflakeSQL($df);},
      DUCKDB: {db | meta::pure::dsl::duckdb::generateDuckDBSQL($df);},
      BIGQUERY: {db | meta::pure::dsl::bigquery::generateBigQuerySQL($df);}
   ]);
}

;// Convenience functions for generating SQL for specific databases
function meta::pure::dsl::dataframe::generateSnowflakeSQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::snowflake::generateSnowflakeSQL($df);
}

;function meta::pure::dsl::dataframe::generateDuckDBSQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::duckdb::generateDuckDBSQL($df);
}

;function meta::pure::dsl::dataframe::generateBigQuerySQL(df: DataFrame[1]);: String[1]
{
   meta::pure::dsl::bigquery::generateBigQuerySQL($df);
}
;