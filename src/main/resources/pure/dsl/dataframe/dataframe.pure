// Copyright 2025 Neema Raphael
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dsl::dataframe::*;
import meta::pure::dsl::dataframe::metamodel::*;

/**
 * Core DataFrame DSL for modeling SQL SELECT statements
 * This DSL provides a unified interface for creating SQL queries that can be
 * executed against both Snowflake and DuckDB databases.
 */

// Core DataFrame metamodel
Class meta::pure::dsl::dataframe::metamodel::DataFrame
{
   columns : Column[*];
   source : DataSource[0..1];
   filter : FilterCondition[0..1];
   groupBy : GroupByClause[0..1];
   having : FilterCondition[0..1];
   orderBy : OrderByClause[*];
   limit : Integer[0..1];
   offset : Integer[0..1];
   distinct : Boolean[0..1];
}

// Column representation
Class meta::pure::dsl::dataframe::metamodel::Column
{
   name : String[1];
   expression : Expression[1];
   alias : String[0..1];
}

// Abstract base class for all expressions
Class meta::pure::dsl::dataframe::metamodel::Expression
{
}

// Literal value expression
Class meta::pure::dsl::dataframe::metamodel::LiteralExpression extends Expression
{
   value : Any[1];
}

// Column reference expression
Class meta::pure::dsl::dataframe::metamodel::ColumnReference extends Expression
{
   columnName : String[1];
   tableAlias : String[0..1];
}

// Function call expression
Class meta::pure::dsl::dataframe::metamodel::FunctionExpression extends Expression
{
   functionName : String[1];
   parameters : Expression[*];
}

// Data source (table, subquery, etc.)
Class meta::pure::dsl::dataframe::metamodel::DataSource
{
}

// Table reference
Class meta::pure::dsl::dataframe::metamodel::TableReference extends DataSource
{
   tableName : String[1];
   schema : String[0..1];
   alias : String[0..1];
}

// Join operation
Class meta::pure::dsl::dataframe::metamodel::JoinOperation extends DataSource
{
   left : DataSource[1];
   right : DataSource[1];
   joinType : JoinType[1];
   condition : FilterCondition[1];
}

// Join types
Enum meta::pure::dsl::dataframe::metamodel::JoinType
{
   INNER,
   LEFT_OUTER,
   RIGHT_OUTER,
   FULL_OUTER,
   CROSS
}

// Subquery as a data source
Class meta::pure::dsl::dataframe::metamodel::SubquerySource extends DataSource
{
   dataFrame : DataFrame[1];
   alias : String[1];
}

// Filter condition
Class meta::pure::dsl::dataframe::metamodel::FilterCondition extends Expression
{
}

// Binary operation (e.g., =, >, <, etc.)
Class meta::pure::dsl::dataframe::metamodel::BinaryOperation extends FilterCondition
{
   left : Expression[1];
   operator : BinaryOperator[1];
   right : Expression[1];
}

// Binary operators
Enum meta::pure::dsl::dataframe::metamodel::BinaryOperator
{
   EQUALS,
   NOT_EQUALS,
   GREATER_THAN,
   LESS_THAN,
   GREATER_THAN_OR_EQUALS,
   LESS_THAN_OR_EQUALS,
   AND,
   OR,
   LIKE,
   IN,
   NOT_IN,
   IS_NULL,
   IS_NOT_NULL
}

// Unary operation (e.g., NOT)
Class meta::pure::dsl::dataframe::metamodel::UnaryOperation extends FilterCondition
{
   operator : UnaryOperator[1];
   expression : Expression[1];
}

// Unary operators
Enum meta::pure::dsl::dataframe::metamodel::UnaryOperator
{
   NOT
}

// Group by clause
Class meta::pure::dsl::dataframe::metamodel::GroupByClause
{
   columns : Expression[*];
}

// Order by clause
Class meta::pure::dsl::dataframe::metamodel::OrderByClause
{
   expression : Expression[1];
   direction : SortDirection[1];
}

// Sort direction
Enum meta::pure::dsl::dataframe::metamodel::SortDirection
{
   ASC,
   DESC
}

// Aggregate functions
Class meta::pure::dsl::dataframe::metamodel::AggregateFunction extends FunctionExpression
{
}

// Common aggregate functions
Class meta::pure::dsl::dataframe::metamodel::CountFunction extends AggregateFunction
{
   distinct : Boolean[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::SumFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::AvgFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::MinFunction extends AggregateFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::MaxFunction extends AggregateFunction
{
}

// Window function classes
Class meta::pure::dsl::dataframe::metamodel::WindowFunction extends FunctionExpression
{
   window : Window[1];
}

Class meta::pure::dsl::dataframe::metamodel::Window
{
   partitionBy : Expression[*];
   orderBy : OrderByClause[*];
   frameType : WindowFrameType[0..1];
   frameStart : WindowFrameBound[0..1];
   frameEnd : WindowFrameBound[0..1];
}

Enum meta::pure::dsl::dataframe::metamodel::WindowFrameType
{
   ROWS,
   RANGE
}

Class meta::pure::dsl::dataframe::metamodel::WindowFrameBound
{
   type : WindowFrameBoundType[1];
   offset : Integer[0..1];
}

Enum meta::pure::dsl::dataframe::metamodel::WindowFrameBoundType
{
   UNBOUNDED_PRECEDING,
   PRECEDING,
   CURRENT_ROW,
   FOLLOWING,
   UNBOUNDED_FOLLOWING
}

// Specialized window functions
Class meta::pure::dsl::dataframe::metamodel::RowNumberFunction extends WindowFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::RankFunction extends WindowFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::DenseRankFunction extends WindowFunction
{
}

Class meta::pure::dsl::dataframe::metamodel::LeadLagFunction extends WindowFunction
{
   offset : Expression[0..1];
   defaultValue : Expression[0..1];
   ignoreNulls : Boolean[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::FirstLastValueFunction extends WindowFunction
{
   ignoreNulls : Boolean[0..1];
}

Class meta::pure::dsl::dataframe::metamodel::AggregateWindowFunction extends WindowFunction
{
}

// Factory functions for creating DataFrame objects
function meta::pure::dsl::dataframe::newDataFrame(): DataFrame[1]
{
   ^DataFrame(columns = [], distinct = false)
}

function meta::pure::dsl::dataframe::select(columns: Column[*]): DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = false)
}

function meta::pure::dsl::dataframe::selectDistinct(columns: Column[*]): DataFrame[1]
{
   ^DataFrame(columns = $columns, distinct = true)
}

function meta::pure::dsl::dataframe::from(df: DataFrame[1], source: DataSource[1]): DataFrame[1]
{
   ^$df(source = $source)
}

function meta::pure::dsl::dataframe::where(df: DataFrame[1], condition: FilterCondition[1]): DataFrame[1]
{
   ^$df(filter = $condition)
}

function meta::pure::dsl::dataframe::groupBy(df: DataFrame[1], columns: Expression[*]): DataFrame[1]
{
   ^$df(groupBy = ^GroupByClause(columns = $columns))
}

function meta::pure::dsl::dataframe::having(df: DataFrame[1], condition: FilterCondition[1]): DataFrame[1]
{
   ^$df(having = $condition)
}

function meta::pure::dsl::dataframe::orderBy(df: DataFrame[1], clauses: OrderByClause[*]): DataFrame[1]
{
   ^$df(orderBy = $clauses)
}

function meta::pure::dsl::dataframe::limit(df: DataFrame[1], limit: Integer[1]): DataFrame[1]
{
   ^$df(limit = $limit)
}

function meta::pure::dsl::dataframe::offset(df: DataFrame[1], offset: Integer[1]): DataFrame[1]
{
   ^$df(offset = $offset)
}

// Helper functions for creating expressions
function meta::pure::dsl::dataframe::col(name: String[1]): ColumnReference[1]
{
   ^ColumnReference(columnName = $name)
}

function meta::pure::dsl::dataframe::col(tableName: String[1], columnName: String[1]): ColumnReference[1]
{
   ^ColumnReference(columnName = $columnName, tableAlias = $tableName)
}

function meta::pure::dsl::dataframe::literal(value: Any[1]): LiteralExpression[1]
{
   ^LiteralExpression(value = $value)
}

function meta::pure::dsl::dataframe::as(expr: Expression[1], alias: String[1]): Column[1]
{
   ^Column(name = $alias, expression = $expr, alias = $alias)
}

// Helper functions for creating conditions
function meta::pure::dsl::dataframe::eq(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::neq(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.NOT_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::gt(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.GREATER_THAN, right = $right)
}

function meta::pure::dsl::dataframe::lt(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.LESS_THAN, right = $right)
}

function meta::pure::dsl::dataframe::gte(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.GREATER_THAN_OR_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::lte(left: Expression[1], right: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.LESS_THAN_OR_EQUALS, right = $right)
}

function meta::pure::dsl::dataframe::and(left: FilterCondition[1], right: FilterCondition[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.AND, right = $right)
}

function meta::pure::dsl::dataframe::or(left: FilterCondition[1], right: FilterCondition[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $left, operator = BinaryOperator.OR, right = $right)
}

function meta::pure::dsl::dataframe::not(expr: FilterCondition[1]): UnaryOperation[1]
{
   ^UnaryOperation(operator = UnaryOperator.NOT, expression = $expr)
}

function meta::pure::dsl::dataframe::like(expr: Expression[1], pattern: String[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.LIKE, right = ^LiteralExpression(value = $pattern))
}

function meta::pure::dsl::dataframe::isNull(expr: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.IS_NULL, right = ^LiteralExpression(value = 'null'))
}

function meta::pure::dsl::dataframe::isNotNull(expr: Expression[1]): BinaryOperation[1]
{
   ^BinaryOperation(left = $expr, operator = BinaryOperator.IS_NOT_NULL, right = ^LiteralExpression(value = 'null'))
}

// Helper functions for creating data sources
function meta::pure::dsl::dataframe::table(name: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name)
}

function meta::pure::dsl::dataframe::table(schema: String[1], name: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, schema = $schema)
}

function meta::pure::dsl::dataframe::tableAs(name: String[1], alias: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, alias = $alias)
}

function meta::pure::dsl::dataframe::tableAs(schema: String[1], name: String[1], alias: String[1]): TableReference[1]
{
   ^TableReference(tableName = $name, schema = $schema, alias = $alias)
}

function meta::pure::dsl::dataframe::join(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.INNER, condition = $condition)
}

function meta::pure::dsl::dataframe::leftJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.LEFT_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::rightJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.RIGHT_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::fullJoin(left: DataSource[1], right: DataSource[1], condition: FilterCondition[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.FULL_OUTER, condition = $condition)
}

function meta::pure::dsl::dataframe::crossJoin(left: DataSource[1], right: DataSource[1]): JoinOperation[1]
{
   ^JoinOperation(left = $left, right = $right, joinType = JoinType.CROSS, condition = ^BinaryOperation(left = ^LiteralExpression(value = true), operator = BinaryOperator.EQUALS, right = ^LiteralExpression(value = true)))
}

// Helper functions for creating aggregate functions
function meta::pure::dsl::dataframe::count(expr: Expression[1]): CountFunction[1]
{
   ^CountFunction(functionName = 'count', parameters = [$expr], distinct = false)
}

function meta::pure::dsl::dataframe::countDistinct(expr: Expression[1]): CountFunction[1]
{
   ^CountFunction(functionName = 'count', parameters = [$expr], distinct = true)
}

function meta::pure::dsl::dataframe::sum(expr: Expression[1]): SumFunction[1]
{
   ^SumFunction(functionName = 'sum', parameters = [$expr])
}

function meta::pure::dsl::dataframe::avg(expr: Expression[1]): AvgFunction[1]
{
   ^AvgFunction(functionName = 'avg', parameters = [$expr])
}

function meta::pure::dsl::dataframe::min(expr: Expression[1]): MinFunction[1]
{
   ^MinFunction(functionName = 'min', parameters = [$expr])
}

function meta::pure::dsl::dataframe::max(expr: Expression[1]): MaxFunction[1]
{
   ^MaxFunction(functionName = 'max', parameters = [$expr])
}

// Helper functions for creating order by clauses
function meta::pure::dsl::dataframe::asc(expr: Expression[1]): OrderByClause[1]
{
   ^OrderByClause(expression = $expr, direction = SortDirection.ASC)
}

function meta::pure::dsl::dataframe::desc(expr: Expression[1]): OrderByClause[1]
{
   ^OrderByClause(expression = $expr, direction = SortDirection.DESC)
}

// Window function helper functions
function meta::pure::dsl::dataframe::over(expr: Expression[1], window: Window[1]): WindowFunction[1]
{
   let functionName = $expr->getFunctionName();
   
   if($functionName == 'row_number')
   {
      ^RowNumberFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'rank')
   {
      ^RankFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'dense_rank')
   {
      ^DenseRankFunction(functionName = $functionName, parameters = [], window = $window);
   }
   else if($functionName == 'lead' || $functionName == 'lag')
   {
      let params = $expr->getFunctionParameters();
      let valueExpr = $params->at(0);
      let offset = if($params->size() >= 2, |$params->at(1), |^LiteralExpression(value = 1));
      let defaultValue = if($params->size() >= 3, |$params->at(2), |^LiteralExpression(value = null));
      
      ^LeadLagFunction(functionName = $functionName, parameters = [$valueExpr], window = $window, offset = $offset, defaultValue = $defaultValue);
   }
   else if($functionName == 'first_value' || $functionName == 'last_value')
   {
      let params = $expr->getFunctionParameters();
      let valueExpr = $params->at(0);
      
      ^FirstLastValueFunction(functionName = $functionName, parameters = [$valueExpr], window = $window);
   }
   else
   {
      // Default to aggregate window function for sum, avg, min, max, count, etc.
      let params = if($expr->instanceOf(FunctionExpression), 
                     |$expr->cast(@FunctionExpression).parameters, 
                     |[$expr]);
      
      ^AggregateWindowFunction(functionName = $functionName, parameters = $params, window = $window);
   }
}

function meta::pure::dsl::dataframe::getFunctionName(expr: Expression[1]): String[1]
{
   if($expr->instanceOf(FunctionExpression),
      |$expr->cast(@FunctionExpression).functionName,
      |'');
}

function meta::pure::dsl::dataframe::getFunctionParameters(expr: Expression[1]): Expression[*]
{
   if($expr->instanceOf(FunctionExpression),
      |$expr->cast(@FunctionExpression).parameters,
      |[]);
}

function meta::pure::dsl::dataframe::partitionBy(columns: Expression[*]): Window[1]
{
   ^Window(partitionBy = $columns, orderBy = []);
}

function meta::pure::dsl::dataframe::orderBy(window: Window[1], clauses: OrderByClause[*]): Window[1]
{
   ^$window(orderBy = $clauses);
}

function meta::pure::dsl::dataframe::rowsUnboundedPreceding(window: Window[1]): Window[1]
{
   ^$window(
      frameType = WindowFrameType.ROWS, 
      frameStart = ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_PRECEDING),
      frameEnd = ^WindowFrameBound(type = WindowFrameBoundType.CURRENT_ROW)
   );
}

function meta::pure::dsl::dataframe::rowsBetween(window: Window[1], start: WindowFrameBound[1], end: WindowFrameBound[1]): Window[1]
{
   ^$window(frameType = WindowFrameType.ROWS, frameStart = $start, frameEnd = $end);
}

function meta::pure::dsl::dataframe::rangeBetween(window: Window[1], start: WindowFrameBound[1], end: WindowFrameBound[1]): Window[1]
{
   ^$window(frameType = WindowFrameType.RANGE, frameStart = $start, frameEnd = $end);
}

function meta::pure::dsl::dataframe::unboundedPreceding(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_PRECEDING);
}

function meta::pure::dsl::dataframe::unboundedFollowing(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.UNBOUNDED_FOLLOWING);
}

function meta::pure::dsl::dataframe::currentRow(): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.CURRENT_ROW);
}

function meta::pure::dsl::dataframe::preceding(offset: Integer[1]): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.PRECEDING, offset = $offset);
}

function meta::pure::dsl::dataframe::following(offset: Integer[1]): WindowFrameBound[1]
{
   ^WindowFrameBound(type = WindowFrameBoundType.FOLLOWING, offset = $offset);
}

// Window function factory functions
function meta::pure::dsl::dataframe::rowNumber(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'row_number', parameters = []);
}

function meta::pure::dsl::dataframe::rank(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'rank', parameters = []);
}

function meta::pure::dsl::dataframe::denseRank(): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'dense_rank', parameters = []);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1], offset: Integer[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr, literal($offset)]);
}

function meta::pure::dsl::dataframe::lead(expr: Expression[1], offset: Integer[1], defaultValue: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lead', parameters = [$expr, literal($offset), $defaultValue]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1], offset: Integer[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr, literal($offset)]);
}

function meta::pure::dsl::dataframe::lag(expr: Expression[1], offset: Integer[1], defaultValue: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'lag', parameters = [$expr, literal($offset), $defaultValue]);
}

function meta::pure::dsl::dataframe::firstValue(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'first_value', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::lastValue(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'last_value', parameters = [$expr]);
}

// Aggregate function factory functions
function meta::pure::dsl::dataframe::sum(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'sum', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::avg(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'avg', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::min(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'min', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::max(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'max', parameters = [$expr]);
}

function meta::pure::dsl::dataframe::count(expr: Expression[1]): FunctionExpression[1]
{
   ^FunctionExpression(functionName = 'count', parameters = [$expr]);
}
